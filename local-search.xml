<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代数学基础</title>
    <link href="/2021/11/23/%E4%BB%A3%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/11/23/%E4%BB%A3%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="代数一：代数学基础（2021秋）"><a href="#代数一：代数学基础（2021秋）" class="headerlink" title="代数一：代数学基础（2021秋）"></a>代数一：代数学基础（2021秋）</h1><hr><h2 id="第一章：预备知识"><a href="#第一章：预备知识" class="headerlink" title="第一章：预备知识"></a>第一章：预备知识</h2><p>习题1.1 对于任何集合X，我们用idx表示X到自身的恒等映射.设f：A </p>]]></content>
    
    
    
    <tags>
      
      <tag>代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学分析</title>
    <link href="/2021/11/23/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/"/>
    <url>/2021/11/23/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="数学分析-史济怀-中科大-2021秋"><a href="#数学分析-史济怀-中科大-2021秋" class="headerlink" title="数学分析 史济怀 中科大 2021秋"></a>数学分析 史济怀 中科大 2021秋</h1><p>接下来将舍弃一切去战斗。从8月27号开学到现在，数分已经学习了两个多月，我在期中的表现不尽如人意。现在迫切的需要反思自己的学习思路和方法，先放下和别人的差距不谈，先问问自己有没有做的竭尽全力？答案是否定的，我至今尚未建立一个分析语言体系，导致在分析思考问题的时候很僵硬，不知道如何下手，这本质上是因为对课本的理解不到位。看起来看的书比较多，实际上等于没读！说的过分一点，这样子看书无异于在厕所里面读报纸。所以接下来需要切实的整理自己的笔记和思路。</p><h2 id="第一章：实数和数列极限"><a href="#第一章：实数和数列极限" class="headerlink" title="第一章：实数和数列极限"></a>第一章：实数和数列极限</h2><p>前言：作者在这一章将介绍极限的基本概念，是初入高等数学大门的第一关。那么如何介绍极限？作者从第一节实数讲起，告知读者什么是实数，以及为何要定义实数。接着步入数列。这里作者介绍了收敛是数列的一种行为（n越来越大，an越来越接近一个数）并且引入了$\varepsilon$-N语言，给出了这套语言如何定义极限。接着给出了几个常用数列极限的证明（贯穿整个分析学学习）。接下来讲解实数完备性的六条基本定理。最后给出数列的上下极限概念以及介绍Stolz定理用于数列极限的求解。</p><h3 id="1-1实数"><a href="#1-1实数" class="headerlink" title="1.1实数"></a>1.1实数</h3><p>分数都是有尽小数和无尽不循环小数（有尽小数可以写成无尽循环小数，例如1.0=0.9999999$\cdots$），实数则是全体无尽小数。<br>无尽循环小数可以化为分数，下列给出操作步骤<br>$$<br>对于一个无尽循环小数3.\dot{1}4285\dot{7},可令3.\dot{1}4285\dot{7}=3+a,则有10^6a=142857+a,解出a，将a加上3即可得最终分数<br>$$<br>每一个实数都能用有理数去逼近到任意精确的程度。<br>有理数集与乘法，加法运算构成了域（仅仅通过四则运算，我们不能得到有理数以外的东西）!</p><p>一般想要证明一个数$\alpha$为无理数，常采取反证法：假设数$\alpha$为有理数，设为$\alpha$=$\frac{p}{q}$（p,q一般情况下设为即约分数，即p,q互素）,通过题目给出的$\alpha$的性质，推出矛盾即可<br>这里的矛盾一般为1、即约分数表示的唯一性（即p,q此时没有除1以外的公因子）2、利用无穷递降法（正整数不可能无止境的递减下去）</p><h3 id="1-2数列和收敛数列"><a href="#1-2数列和收敛数列" class="headerlink" title="1.2数列和收敛数列"></a>1.2数列和收敛数列</h3>]]></content>
    
    
    
    <tags>
      
      <tag>分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翁恺MOOC程序设计笔记</title>
    <link href="/2021/11/16/%E7%BF%81%E6%81%BAMOOC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/11/16/%E7%BF%81%E6%81%BAMOOC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>输入是以行为单位进行的，行的结束标志就是按下了回车键。在按下回车之前，程序不会读到任何东西。</p><p>变量：保存数据的地方。用一个变量保存了数据，它才能参加到后面的计算中去。<br><strong>变量定义的一般形式：&lt;类型名称&gt;&lt;变量名称&gt;;</strong><br>变量的名字是一种“<strong>标识符</strong>”，用来识别这个和那个的不同的名字。<br><strong>标识符基本构造原则</strong>：只能由字母，数字和下划线组成，数字不可以出现在第一个位置上，C语言的关键字（有的地方称为<strong>保留字</strong>）不可以用做标识符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span>,<span class="hljs-keyword">break</span>,<span class="hljs-keyword">case</span>,<span class="hljs-keyword">char</span>,<span class="hljs-keyword">const</span>,<span class="hljs-keyword">continue</span>,<span class="hljs-keyword">default</span>,<br><span class="hljs-keyword">do</span>,<span class="hljs-keyword">double</span>,<span class="hljs-keyword">else</span>,<span class="hljs-keyword">enum</span>,<span class="hljs-keyword">extern</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">for</span>,<span class="hljs-keyword">goto</span>,<br><span class="hljs-keyword">if</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">long</span>,<span class="hljs-keyword">register</span>,<span class="hljs-keyword">return</span>,<span class="hljs-keyword">short</span>,<br><span class="hljs-keyword">signed</span>,<span class="hljs-keyword">sizeof</span>,<span class="hljs-keyword">static</span>,struct,<span class="hljs-keyword">switch</span>,<br><span class="hljs-keyword">typedef</span>,<span class="hljs-keyword">union</span>,<span class="hljs-keyword">unsigned</span>,<span class="hljs-keyword">void</span>,<span class="hljs-keyword">volatile</span>,<span class="hljs-keyword">while</span>,<br><span class="hljs-keyword">inline</span>,<span class="hljs-keyword">restrict</span><br></code></pre></td></tr></table></figure><p>(以上不需要背诵)<br>C语言没有强制要求变量在被定义时就初始化，但在第一次被使用之前应该被赋值一次。（如果没有初始化，则会随机出现奇怪的数值）<br><strong>变量初始化：&lt;类型名称&gt;&lt;变量名称&gt;=&lt;初始值&gt;;</strong><br><strong>表达式：有运算符的式子就叫做表达式。</strong><br>C99允许在程序的任何地方定义变量<br>传统ANSI C只能在代码开头的地方定义变量<br>固定不变的数，是常数。直接写在程序里，我们称作**直接量（literal)**。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义一个常量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> AMOUNT = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>const是一个修饰符，用来给这个变量加上一个const(不变的)的属性。<br>const属性表示这个变量的值一旦初始化，就不能再修改了。<br>若强行进行赋值操作，编译器会发现这个错误并且指出。</p><p>当浮点数和整数放在一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算。<br>double双精度浮点数；float单精度浮点数</p><p>运算符(operator)是指进行运算的动作：加法运算符“+”，减法运算符“-”<br>算子(operand)指参与运算的值：常数，变量，某个方法的返回值</p><p><strong>运算符优先级</strong></p><table><thead><tr><th>优先级</th><th>运算符</th><th>运算</th><th>结合关系</th><th>举例</th></tr></thead><tbody><tr><td>1</td><td>+</td><td>单目不变</td><td>自右向左</td><td>a*+b</td></tr><tr><td>1</td><td>-</td><td>单目取负</td><td>自右向左</td><td>a*-b</td></tr><tr><td>2</td><td>*</td><td>乘</td><td>自左向右</td><td>a*b</td></tr><tr><td>2</td><td>/</td><td>除</td><td>自左向右</td><td>a/b</td></tr><tr><td>2</td><td>%</td><td>取余</td><td>自左向右</td><td>a%b</td></tr><tr><td>3</td><td>+</td><td>加</td><td>自左向右</td><td>a+b</td></tr><tr><td>3</td><td>-</td><td>减</td><td>自左向右</td><td>a-b</td></tr><tr><td>4</td><td>=</td><td>赋值</td><td>自右向左</td><td>a=b</td></tr></tbody></table><p>赋值运算符<br><strong>赋值也是运算，也有结果！</strong>a=6的结果是a被赋予的值，也就是6<br>不要用“嵌入式赋值”！！（不利于阅读，容易产生错误）</p><p>结合关系：一般自左向右（单目+-和赋值时自右向左）</p><p>设置断点：程序运行到断点时将会停止，不会执行被设为断点的那一行程序。（用来进行程序debug。）</p><p><strong>复合赋值</strong>：5个算术运算符，+-/%，可以和赋值运算符“=”结合起来，形成复合赋值运算符：“+=”，“-=”，“*=”，“/=”和“%=”（两个运算符中间不要有空格！）<br>例：total += 5;<br>        total = total + 5;</p><p><strong>递增递减运算符（++和–）</strong>：单目运算符，其算子必须是变量，作用是给这个变量+1或者-1。<br>前缀后缀：放在变量的前面叫做前缀形式，放在变量后面叫做后缀形式。<br><strong>a++的值是a加1以前的值，而++a的值是加了1以后的值。</strong></p><table><thead><tr><th>表达式</th><th>运算</th><th>表达式的值</th></tr></thead><tbody><tr><td>count++</td><td>给count加1</td><td>count原来的值</td></tr><tr><td>++count</td><td>给count加1</td><td>count+1以后的值</td></tr><tr><td>count–</td><td>给count减1</td><td>count原来的值</td></tr><tr><td>–count</td><td>给count减1</td><td>count-1以后的值</td></tr></tbody></table><p><strong>关系运算：计算两个值之间的关系</strong></p><table><thead><tr><th align="center">运算符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">相等</td></tr><tr><td align="center">！=</td><td align="center">不相等</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于或等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于或等于</td></tr></tbody></table><p><strong>关系运算的结果：当两个值的关系符合关系运算符的预期时，关系运算的结果为整数1，否则为整数0。</strong><br>关系运算符的<strong>优先级</strong>：所有的关系运算符的优先级<strong>比算数运算符的低</strong>，但是<strong>比赋值运算的高</strong>。==与！=的优先级比其他的低，而连续的关系运算是<strong>从左到右</strong>进行的。</p><p>if语句：如果表示条件的逻辑表达式的结果<strong>不是0</strong>，那么就执行后面跟着的大括号中的语句，否则就跳过这些语句不执行，而继续下面的其他语句。</p><p><strong>else总是和最近的那个if去匹配（不添加大括号的情况下）。</strong><br>良好的习惯：**在if或else后面总是用{}**（即使只有一条语句的时候）。</p><p>if-else常见的错误：忘了大括号；if后面加分号（C编译器不会认为凭空出现的大括号有问题！）；错误使用==和=（程序会出现warning!）；</p><p>switch-case语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span>(控制表达式) <span class="hljs-comment">//控制表达式只能是整数型的结果</span><br>&#123;                <span class="hljs-comment">//常量可以是常数，也可以是常数计算的表达式</span><br>   <span class="hljs-keyword">case</span> 常量:    <br>        语句   <br>        ....<br>   <span class="hljs-keyword">case</span> 常量:<br>        语句<br>        ....<br>   <span class="hljs-keyword">default</span>:<br>        语句<br>        ....<br>&#125;<br><span class="hljs-comment">//在执行完分支中的最后一条语句后，如果后面没有break,就会顺序执行到下面的case里去，直到遇到一个break或者switch结束为止。</span><br><span class="hljs-comment">//case只是一个入口，而没有将switch划分！</span><br></code></pre></td></tr></table></figure><p>编写代码尽量满足<strong>“单一出口”</strong>原则：一个函数里面只有末尾一个return（或者void函数完全没有return而在最后一个语句之后自动返回），中间没有其他的return语句。</p><p>while循环体内需要有改变条件的机会，否则将会成为死循环。<br>while翻译作“当”：当条件满足时，不断地重复循环体内的语句。（条件成立时循环继续的条件）</p><p>do-while循环（执行完一轮循环体的代码后，再来检查循环体的条件是否满足，如果满足则继续下一轮循环，不满足则结束循环）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span><br>&#123;<br>    &lt;循环体语句&gt;<br>&#125;<span class="hljs-keyword">while</span>(&lt;循环条件&gt;);<br></code></pre></td></tr></table></figure><p>计数循环小套路：如果要模拟运行一个很大次数的循环，可以模拟较少的循环次数，然后作出推断。</p><p><strong>随机数：每次召唤rand（）就得到一个随机的整数。</strong></p><p>for(初始条件；循环继续的条件；循环每一轮要做的事情)<br>for=对于<br>for(count=10;count&gt;0;count–)<br>读作：“对于一开始的count=10,当count&gt;0时，重复做循环体，每一轮循环在做完循环体内语句后，使得count–。”<br>小套路：做求和的程序时，记录结果的变量应该初始化为0，而做求积的变量时，记录结果的变量应该初始化为1。<br>循环控制变量i只在循环里被使用了，在循环外面它没有任何用处。因此，我们可以把<strong>变量i的定义写到for语句里面去</strong>。（在C99里面用！）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br></code></pre></td></tr></table></figure><p>for中的每一个表达式都是可以<br><strong>for(;条件;)==while(条件)</strong></p><p><strong>Tips for loops:如果有固定次数，用for；如果必须执行一次，用do-while；其他情况用while</strong></p><p><strong>break：跳出循环</strong><br><strong>continue：跳过循环这一轮剩下的语句进入下一轮</strong><br>break和continue只能对它所在的那层循环做<br><strong>goto语句：无条件转移（不建议使用，只使用在多重循环结构中）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">goto</span> out;<br>&lt;语句&gt;<br>out:<br></code></pre></td></tr></table></figure><h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>C++/Java更强调类型，对类型的检查更严格<br>JavaScript,Python,PHP不看重类型，甚至不需要事先定义。</p><p>C语言的类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">·整数<br> ·<span class="hljs-keyword">char</span>,<span class="hljs-keyword">short</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">long</span>,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span><br>·浮点数<br> ·<span class="hljs-keyword">float</span>,<span class="hljs-keyword">double</span>,<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span><br>·逻辑<br> ·<span class="hljs-keyword">bool</span><br>·指针<br>·自定义类型<br></code></pre></td></tr></table></figure><p><strong>表达的数的范围:char&lt;short&lt;int&lt;float&lt;double</strong></p><p>sizeof：是一个运算符，给出某个类型或变量在内存中所占据的字节数<br>sizeof(int);sizeof(i);<br>sizeof（）函数的意思是输出括号内的变量所占的内存空间。<strong>（只看表达式的数据类型！）</strong></p><p>整数</p><table><thead><tr><th align="center">整数</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1字节（8比特）</td></tr><tr><td align="center">short</td><td align="center">2字节</td></tr><tr><td align="center">int</td><td align="center">取决于CPU，通常的意义是“1个字”</td></tr><tr><td align="center">long</td><td align="center">取决于CPU，通常的意义是“1个字”</td></tr><tr><td align="center">long long</td><td align="center">8字节</td></tr></tbody></table><p>整数的内部表达：计算机内部一切都是二进制 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">18</span>--&gt;<span class="hljs-number">00010010</span><br><span class="hljs-number">0</span>--&gt;<span class="hljs-number">00000000</span><br><span class="hljs-number">-18</span>--&gt;?<br></code></pre></td></tr></table></figure><p>二进制负数<br>1个字节可以表达的数：00000000–11111111（0-255）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>仿制十进制，有一个特殊的标志表示负数<br><span class="hljs-number">2.</span>取中间的数为<span class="hljs-number">0</span>，如<span class="hljs-number">100000000</span>表示<span class="hljs-number">0</span>，比它小的是负数，比它大的是正数<br><span class="hljs-number">3.</span>补码<br></code></pre></td></tr></table></figure><p><strong>补码的意义就是拿补码和原码可以加出一个溢出的“零”</strong></p><p>数的范围：对于一个字节（8位），可以表达的是<br>00000000-11111111<br>00000000-&gt;0,11111111<del>10000000-&gt;-1</del>-128,00000001<del>01111111-&gt;1</del>127<br>11111111被当作纯二进制看待时，是255，被当作补码看待时是-1<br>如果一个字面量常数想要表达自己是unsigned，可以在后面加u或U<br>用l或L表示long(long)<br>*unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位</p><p>整数的输入输出<br>只有两种形式：int或long long<br>%d：int<br>%u：unsigned<br>%ld：long long<br>%lu：unsigned long long</p><p>8进制和16进制<br>一个以0开始的数字<strong>字面量</strong>是8进制<br>一个以0x开始的数字<strong>字面量</strong>是16进制<br>%o用于8进制，%x用于16进制<br>8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关！</p><p>选择整数类型<br>整数这么多种的原因：为了准确表达内存，做底层程序的需要<br><strong>没有特殊需要，就选择int</strong><br>现在的CPU字长都是32位或者64位，一次内存读写就是一个int，一次计算也是一个int（选择更短的类型不会更快，甚至可能更慢）<br>*现代编译器一般会设计<strong>内存对齐</strong>，所以更短的类型实际在内存中有可能也占据一个int的大小<br>unsigned与否只是输出的不同，内部计算是一样的！ </p><p><strong>浮点类型</strong></p><table><thead><tr><th>类型</th><th>scanf</th><th>printf</th><th>字长</th><th>范围</th><th>有效数字</th></tr></thead><tbody><tr><td>float</td><td>%f</td><td>%f,%e</td><td>32</td><td>(-2^128 ~ +2^128),0,±inf,nan</td><td>7</td></tr><tr><td>double</td><td>%lf</td><td>%f,%e</td><td>64</td><td>(-2^1024 ~ +2^1024),0,±inf,nan</td><td>15</td></tr></tbody></table><p>%e:输出科学计数法<br>可选的+或-符号，可以用e或E，小数点也可选，符号可以是-或+也可以省略（表示+）<br>-5.67E+16</p><p>输出精度：在%和f之间加上.n可以指定输出小数点后几位，这样的输出是做四舍五入的。<br>超过范围的浮点数<br>printf输出inf表示超过范围的浮点数：±∞<br>printf输出nan表示不存在的浮点数</p><p><strong>带小数点的字面量是double而非float</strong><br>float需要用f或F后缀来表明身份<br>注意：f1==f2可能失败！可以用fabs(f1-f2)&lt;1e-12来判断</p><p>浮点数的内部表达：<br>浮点数在计算时是由专用的硬件部件实现的<br>计算double和float所用的部件是一样的<br>选择浮点类型：<strong>如果没有特殊需求，只使用double!</strong><br>*现代CPU能直接对double做硬件计算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢</p><p>字符类型（character）<br>char是一种整数，也是一种特殊的类型：字符<br>用单引号表示的字符字面量：’a’,’1’<br>‘ ‘也是一个字符<br>printf和scanf里用%c来输入输出字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">char</span> d;<br>    c = <span class="hljs-number">1</span>;<br>    d = <span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c=%d\n&quot;</span>,c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d=%d\n&quot;</span>,d);<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>简单讲”%d %c”可以以0个或多个空白字符（空格、tab键、回车等）作为分隔符，同时%c不会读取空白字符，%c读取的一定是一个非空白字符，而 “%d%c”会读取一个数和紧挨着这个数的一个字符（包括空白字符）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %c&quot;</span>,&amp;i,&amp;c);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,&amp;i,&amp;c);<br></code></pre></td></tr></table></figure><p>大小写转换<br>大写字母和小写字母是分开排列的，并不在一起（小写字母靠后一些）<br>‘a’-’A‘可以得到两端之间的距离，于是<br><strong>a+’a’-‘A’可以把一个大写字母变成小写字母；a+’A’-‘a’可以把一个小写字母变成大写字母</strong><br><img src="/.com//Blog\source_posts\翁恺MOOC程序设计笔记\ascii.jpg" alt="ascii"></p><p><strong>逃逸字符</strong>：用来表示无法打印出来的控制字符或特殊字符，它由一个反斜杠“\”开头，后面跟上另一个字符，这两个字符合起来，组成了一个字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请分别输入身高的英尺和英寸，&quot;</span><br>      <span class="hljs-string">&quot;如输入\&quot;5 7\&quot;表示5英尺7英寸：&quot;</span>);<br></code></pre></td></tr></table></figure><table><thead><tr><th>字符</th><th>意义</th><th>字符</th><th>意义</th></tr></thead><tbody><tr><td>\b</td><td>回退一格</td><td>\“</td><td>双引号</td></tr><tr><td>\t</td><td>到下一个表格位</td><td>\‘</td><td>单引号</td></tr><tr><td>\n</td><td>换行</td><td>\\</td><td>反斜杠本身</td></tr><tr><td>\r</td><td>回车</td><td></td><td></td></tr></tbody></table><p>自动类型转换：当运算符的两边出现不一致的类型时，会自动转换成较大的类型（大的意思是能表达的数的范围更大）<br>char–&gt;short–&gt;int–&gt;long–&gt;long long<br>int–&gt;float–&gt;double<br>对于printf，任何小于int的类型会被转换成int；float会被转换成double<br>但是scanf不会，要输入short，需要%hd</p><p>强制类型转换：要把一个量强制转换成另一个类型（通常是较小的类型），需要:（类型）值<br>比如：(int)10.2 (short)32<br>注意这时候的安全性，小的变量不总能表达大的量<br>只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型都不改变<br><strong>强制类型转换的优先级高于四则运算</strong></p><p>bool类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>之后就可以使用bool和true,false</p><p>逻辑运算：对逻辑量进行的运算，<strong>结果只有0或1</strong><br>逻辑量是关系运算或逻辑运算的结果</p><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>!</td><td>逻辑非</td><td>!a</td><td>如果a是true结果就是false,如果a是false结果就是true</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td><td>a&amp;&amp;b</td><td>如果a和b都是true,结果就是true；否则就是false</td></tr><tr><td>||</td><td>逻辑或</td><td>a||b</td><td>如果a和b有一个是true,结果就是true；两个都是false,结果就是false</td></tr></tbody></table><p><strong>优先级：！&gt; &amp;&amp; &gt; ||</strong></p><table><thead><tr><th>优先级</th><th>运算符</th><th>结核性</th></tr></thead><tbody><tr><td>1</td><td>()</td><td>从左到右</td></tr><tr><td>2</td><td>! + - ++ –</td><td>从右到左（单目的+和-）</td></tr><tr><td>3</td><td>* / %</td><td>从左到右</td></tr><tr><td>4</td><td>+-</td><td>从左到右</td></tr><tr><td>5</td><td>&lt; &lt;= &gt; &gt;=</td><td>从左到右</td></tr><tr><td>6</td><td>== !=</td><td>从左到右</td></tr><tr><td>7</td><td>&amp;&amp;</td><td>从左到右</td></tr><tr><td>8</td><td>||</td><td>从左到右</td></tr><tr><td>9</td><td>= += -= *= /= %=</td><td>从右到左</td></tr></tbody></table><p><strong>短路：逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算</strong><br>a==6&amp;&amp;b==1<br>a==6&amp;&amp;b+=1<br>对于&amp;&amp;，左边是false时就不做右边了<br>对于||，左边是true时就不做右边了<br><strong>不要把赋值，包括复合赋值组合进表达式！</strong></p><p>条件运算符（三目运算符）<br>count = (count &gt; 20) ? count - 10 : count + 10;<br>条件、条件满足时的值和条件不满足时的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>（count &gt; <span class="hljs-number">20</span> )<br>    count = count - <span class="hljs-number">10</span>;<br><span class="hljs-keyword">else</span><br>    count = count + <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>条件运算符的优先级高于赋值运算符，但是低于其他运算符<br><strong>不要用嵌套条件表达式！</strong></p><p>逗号运算：逗号用来连接两个表达式，并以其<strong>右边的表达式的值作为它的结果</strong>。逗号的<strong>优先级是所有的运算符中最低的</strong>，所以它两边的表达式会先计算；逗号的组合关系是<strong>自左向右</strong>，所以<strong>左边的表达式会先计算</strong>，而<strong>右边的表达式的值就留下来作为逗号运算的结果</strong>。<br>主要是在for中使用逗号运算</p><p><strong>“代码复制”是程序质量不良的表现！</strong></p><h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>函数是一块代码，接受零个或多个参数，做一件事情，并返回零个或一个值。<br>函数定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span>  <span class="hljs-comment">//函数头：返回类型 函数名 参数表</span></span><br><span class="hljs-function">    <span class="hljs-comment">//函数体</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>( i= begin ;i&lt;=end ; i++ )<br>    &#123;<br>        sum +=i;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d到%d的和是%d\n&quot;</span>, begin, end, sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用函数：函数名（参数值）;<br>()起到了表示函数调用的重要作用，即使没有参数也需要()<br>如果有参数，则需要给出正确的数量和顺序，这些值会被按照顺序依次用来初始化函数中的参数<br>如果函数有参数，调用函数时必须传递给它数量、类型正确的值<br>可以传递给函数的值是表达式的结果（字面量、变量、函数返回值、计算结果）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a,b,c;<br>a = <span class="hljs-number">5</span>;<br>b = <span class="hljs-number">6</span>;<br>c - max(<span class="hljs-number">10</span>,<span class="hljs-number">12</span>);<br>c = max(a, b);<br>c = max(c,<span class="hljs-number">23</span>);<br>c = max(max(<span class="hljs-number">23</span>,<span class="hljs-number">45</span>), a);<br>c = max(<span class="hljs-number">23</span>+<span class="hljs-number">45</span>, b);<br></code></pre></td></tr></table></figure><p>如果类型不匹配，调用函数时给的值与参数的类型不匹配是C语言传统上最大的漏洞（编译器总是<strong>悄悄替你把类型转换好</strong>，但是很可能不是你所预期的）后续的语言，C++/Java在这方面很严格</p><p>从函数中返回值<br><strong>return停止函数的执行，并送回一个值</strong><br>return;<br>return 表达式;<br>一个函数里面可以出现多个return语句<br>从函数中返回值：可以赋值给变量，可以再传递给函数，甚至可以丢弃</p><p>没有返回值的函数<br>void函数名（参数表）<br>不能使用带值的return，可以没有return<br>调用的时候不能做返回值的赋值</p><p><strong>函数先后关系</strong><br>C的编译器自上而下顺序分析代码<br>函数原型：函数头，以分号“;”结尾（目的是告诉编译器这个函数长什么样）<br>可以使用函数原型声明（区别于定义，定义包括函数体，可以放在main后面）</p><p>C语言在调用函数时，永远只能传值给函数<br><strong>传值：每个函数都有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系</strong><br>（过去）对于函数参数表中的参数，叫做“形式参数”，调用函数时给的值，叫做“实际参数”（很容易误会调用函数的时候把变量而不是值传进去了）</p><p><strong>本地变量</strong>：函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量（<strong>局部变量</strong>）（自动变量：生存期与作用域）<br>定义在函数内部的变量就是本地变量（参数也是本地变量）</p><p><strong>变量的生存期和作用域</strong><br>生存期：什么时候这个变量开始出现了，到什么时候它消亡了<br>作用域：在（代码的）什么范围内可以访问这个变量（这个变量可以起作用）<br>对于本地变量，这两个问题的答案是统一的：大括号内——块</p><p><strong>本地变量的规则</strong><br>本地变量是定义在块内的，可以定义在函数的块内，也可以定义在语句的块内<br>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了<br>快外面定义的变量在里面仍然有效<br>块里面定义了和外面同名的变量则覆盖了外面的<br>本地变量不会被默认初始化<br>参数在进入函数的时候被初始化了</p><p><strong>函数原型里面的参数类型一定要写明，如果没有就写void，不能留空！</strong></p><p>调用函数时的圆括号里的逗号<strong>是标点符号，不是运算符</strong></p><p>C语言不允许函数嵌套定义</p><p>定义数组<br>&lt;类型&gt;变量名称[元素数量];<br>元素数量必须是整数<br>数组是一种容器（放东西的东西）<br>其中所有的元素具有相同的数据类型<br>一旦创建，不能改变大小<br>*数组中的元素在内存中是连续依次排列的</p><p>使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数<br>编译器和运行环境都不会检查数组下标是否越界，无论是对数组单元做读还是写<br>一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃(segmentation fault)<br>但是也可能运气好，没造成严重的后果（程序员来保证程序只使用有效的下标值：[0,数组的大小-1]）</p><p>数组的集成初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">23</span>,<span class="hljs-number">14</span>,<span class="hljs-number">32</span>&#125;<br><span class="hljs-comment">//直接用大括号给出数组的所有元素的初始值</span><br><span class="hljs-comment">//不需要给出数组的大小，编译器自动数数</span><br></code></pre></td></tr></table></figure><p>集成初始化时的定位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>] = &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>, [<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-comment">//用[n]在初始化数据中给出定位</span><br><span class="hljs-comment">//没有定位的数据接在前面的位置后面</span><br><span class="hljs-comment">//其他位置的值补零</span><br><span class="hljs-comment">//也可以不给出数组的大小，让编译器算</span><br><span class="hljs-comment">//特别适合初始数据稀疏的数组</span><br></code></pre></td></tr></table></figure><p><strong>sizeof给出整个数组所占据的内容的大小，单位是字节</strong>**<br><strong>sizeof(a)/sizeof(a[0])</strong><br>sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单位个数</p><p>数组变量本身不能被赋值<br>要把一个数组的所有元素交给另一个数组，必须采用<strong>遍历</strong><br>遍历数组：通常都是使用for循环，让循环遍历i从0到&lt;数组的长度，这样循环体内最大的i正好是数组最大的有效下标<br>常见错误：循环结束条件是&lt;=数组长度；离开循环后，继续用i的值来做数组元素的下标</p><p><strong>数组作为函数参数时，往往必须再用另一个参数来传入数组的大小</strong><br>数组作为函数的参数时：不能在[]中给出数组的大小，不能再利用sizeof来计算数组的元素个数</p><h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><p>二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">5</span>];<br><span class="hljs-comment">//通常理解为a是一个3行5列的矩阵</span><br></code></pre></td></tr></table></figure><p>二维数组的遍历（需要多重循环）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span> ;i++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">5</span>;j++)<br>    &#123;<br>        a[i][j] = i*j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二维数组的初始化</strong><br>列出是必须给出的，行数可以由编译器来数<br>每行一个{}，逗号分割<br>最后的逗号可以存在<br>如果省略，表示补零<br>也可以用定位</p><p><strong>运算符&amp;</strong><br>scanf(“%d”,&amp;i);里的&amp;<br>获得变量的地址，它的操纵数必须是变量<br>地址的大小是否与int相同取决于编译器</p><p>指针：就是保存地址的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">int</span>* p = &amp;i;<br><span class="hljs-keyword">int</span>* p,q;<br><span class="hljs-keyword">int</span> *p,q;<br><span class="hljs-comment">//三四行等价，表示p是指针，q是一个普通的变量</span><br></code></pre></td></tr></table></figure><p>指针变量：变量的值是内存的地址<br>普通变量的值是实际的值<br>指针变量的值是<strong>具有实际值的变量</strong>的地址</p><p>作为参数的指针<br>void f(int *p);<br>在被调用的时候得到了某个变量的地址：<br>int i=0;f(&amp;i);<br>在函数里面可以通过这个指针访问外面的这个i</p><p>访问那个地址上的变量*<br><em>是一个单目运算符，用来访问指针的值所表示的地址上的变量<br>可以做右值也可以做左值<br><em>左值之所以叫左值是因为出现在赋值号左边的不是变量，而是值，是**表达式计算的结果</em></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">a[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;<br>*p = <span class="hljs-number">3</span>;<br><span class="hljs-comment">//本质上两者(取0下标和取p的地址)都是运算的结果</span><br></code></pre></td></tr></table></figure><p>指针的运算符&amp;*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">*&amp;yptr -&gt; *(&amp;yptr) -&gt; * (yptr的地址) -&gt; 得到那个地址上的变量 -&gt; yptr<br>&amp;*yptr -&gt; &amp;(*yptr) -&gt; &amp;(y) -&gt; 得到y的地址，也就是yptr -&gt; yptr<br><span class="hljs-comment">//互相反作用</span><br></code></pre></td></tr></table></figure><p>传入地址<br>int i;scanf(“%d”,i);为什么编译没有报错？<br>i的值和它的地址刚好都是整数，scanf看不出区别</p><p>指针应用场景<br>一、交换两个变量的值<br>二、函数返回多个值，某些值就只能通过指针返回（传入的参数实际上是需要保存     带回的结果的变量）<br>三、函数返回运算的状态，结果通过指针返回<br>常见套路：<strong>让函数返回特殊的不属于有效范围内的值来表示出错</strong><br>（后续的语言（C++，Java）采用了异常机制来解决这个问题）</p><p><strong>指针最常见的错误</strong><br><strong>定义了指针变量，还没有指向任何变量，就开始使用指针</strong></p><p>传入函数的数组组成了什么？<br><strong>函数参数表中的数组实际上是指针</strong><br>sizeof(a)==sizeof(int*)<br>但是可以用数组的运算符[]进行运算</p><p>数组参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以下四种函数原型是等价的:</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar,<span class="hljs-keyword">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *,<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[],<span class="hljs-keyword">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [],<span class="hljs-keyword">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>数组变量是特殊的指针<br>数组变量本身表达地址，所以<br>int a[10];int *p=a;（无需用&amp;取地址）<br>但是数组的单元表达的是变量，需要用&amp;取地址<br>a == &amp;a[0]<br>[]运算符可以对数组做，也可以对指针做：<br>p[0] &lt;==&gt; a[0]   (p是指针，a是数组)<br>*运算符可以对指针做，也可以对数组做：<br>*a = 25;<br><strong>数组变量是const的指针，所以不能被赋值</strong><br>int b[] –&gt; int * const b;（数组变量是一个常量指针）</p><p><strong>指针是const：表示一旦得到了某个变量的地址，不能再指向其他变量</strong><br><strong>指针所指是const：表示不能通过这个指针去修改那个变量</strong></p><p><strong>const数组</strong><br>const int a[] = {1,2,3,4,5,6,}<br>数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int<br>所以必须通过初始化进行赋值</p><p>因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值<br>为了保护数组不被函数破坏，可以设置参数为const<br>int sum(const int a[],int length);</p><p>给一个指针加1表示要让指针指向下一个变量<br>如果指针不是指向一片连续分配的空间（如数组，则这种运算没有意义）<br><strong>指针计算</strong><br>这些算术运算可以对指针做：<br>给指针加、减一个整数（+，+=，-，-=）<br>递增递减（++/–）<br>两个指针相减：</p><p>*<strong>p++</strong><br>取出p所指的那个数据来，完事之后顺便把p移到下一个位置去<br>*的优先级虽然高，但是没有++高<br>常用于数组类的连续空间操作<br>在某些CPU上，这可以直接被翻译成一条汇编指令</p><p><strong>指针比较</strong><br>&lt;,&lt;=,==,&gt;,&gt;=,!=都可以对指针做<br>比较它们在内存中的地址<br>数组中的单元的地址肯定是线性递增的</p><p>指针的类型<br>无论指向什么类型，所有的指针的大小都是一样的，因为都是地址<br>但是指向不同类型的指针是不能直接互相赋值的（为了避免用错指针）</p><p>用指针来做什么<br>需要传入较大的数据时用作参数<br>传入数组后对数组做操作<br>函数返回不止一个结果<br>需要用函数来修改不止一个变量<br>动态申请内存</p><h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><p>字符数组<br>char word[] = {‘H’,’e’,’l’,’l’,’o’,’!’};<br>这不是C语言的字符串，因为不能用字符串的方式做计</p><p>字符串<br>char word[] = {‘H’,’e’,’l’,’l’,’o’,’!’,’\0’};<br>以0（整数0）结尾的一串字符<br>0或’\0’是一样的，但是和’0’不同<br>0标志字符串的结束，但它不是字符串的一部分<br>计算字符串长度的时候不包含这个0<br>字符串以数组的形式存在，以数组或指针的形式访问（更多的是以指针的形式）<br>string.h里有很多处理字符串的函数</p><p>字符串变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">char</span> word[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">char</span> line[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></td></tr></table></figure><p>字符串常量<br>“Hello”<br>“Hello”会被编译器变成一个字符数组放在某处，这个数组的长度是，结尾还有表示结束的0</p><p>C语言的字符串是以字符数组的形态存在的<br>不能用运算符对字符串做运算<br>通过数组的方式可以遍历字符串<br>唯一特殊的地方是字符串字面量可以用来初始化字符数组</p><p>字符串常量</p>]]></content>
    
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记-《经济学原理》</title>
    <link href="/2021/10/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E3%80%8B/"/>
    <url>/2021/10/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>《经济学原理》-曼昆</strong></p><p>DAY1：2021年10月8日</p><h1 id="本书的总览"><a href="#本书的总览" class="headerlink" title="本书的总览"></a>本书的总览</h1><p><strong>导言部分（最基础的知识）</strong></p><p>第一章：“经济学十大原理”（经济学家的世界观，整个经济学的基础）主要介绍整本书中将出现的重要思想。</p><p>第二章：主要介绍经济学家如何研究他们的研究领域。1，假设在形成理论中的作用2，经济模型的概念3，经济学家在制定政策中的作用4，如何使用图形（包括被误用）</p><p>第三章：1，主要介绍比较优势理论（解释了为什么个人要与其邻居贸易，为什么一个国家要与其他国家贸易）2，市场力量如何协调许多个别的生产和消费决策3，为什么专业化，相互依赖和贸易会有利于每一个人。</p><p><strong>研究供求的工具</strong></p><p>第四章：主要介绍了供给曲线，需求曲线和市场均衡的概念。（供给与需求的市场力量）</p><p>第五章：弹性的概念（分析了三个事件）（弹性及其应用）</p><p>第六章：考察租金控制和最低工资法一类的价格控制，以及税收归宿（供给，需求与政府政策）</p><p>第七章：（消费者，生产者与市场效率）1，用消费者剩余和生产者剩余的概念扩大了供求分析2，消费者支付意愿和需求曲线之间的联系3，生产者生产成本和供给曲线之间的联系4，市场均衡使生产者和消费者剩余之和最大化5，了解市场配置的效率</p><p>第八，九章：实际应用“赋税的价值”（为什么税收引起无谓损失，什么决定了这种损失的大小），“国际贸易”（国际贸易的受益方和受损方，有关保护主义贸易政策的争论）</p><p><strong>微观经济学（较高深）</strong></p><p>为什么市场配置通常是合意的，政府如何改善市场配置。</p><p>第十章：“污染”这一类的外部效应如何会使市场结果无效率（外部性解释），无效率的解决方法（公开或私人）。</p><p>第十一章：“国防“这一类物品没有市场价值时产生的问题（公共物品和公共资源）。</p><p>第十二章：政府如何筹集支付公共物品所必需的收入。1，美国税制的制度背景2，效率和平等目标如何在设计税制时起作用</p><p>第十三章：介绍成本曲线，讨论了包括在企业成本中的内容——生产成本。</p><p>第十四章：介绍市场供给曲线，分析了价格接受企业的行为。</p><p>第十五章：1，讨论了作为市场上唯一卖者的企业的行为。2，讨论垄断定价的无效率，可能的政策反应和垄断者实行价格歧视的努力。（垄断）</p><p>第十六章：介绍只有几家卖家的市场，用囚徒模型解释战略相互作用。（寡头）</p><p>第十七章：1，考察有许多提供相似而不相同产品的卖者的市场行为。2，讨论了广告效果的争论。（垄断竞争）</p><p>第十八章：介绍要素价格与边际生产率之间的联系（生产要素市场）</p><p>第十九章：讨论了均衡工资的决定因素（补偿工资差别，人力资本和歧视）。</p><p>第二十章：1，考察了美国社会的不平等程度2，政府在改变收入分配中作用的不同观点3，帮助社会最贫困成员的各种政策。</p><p>第二十一章：用预算约束线和无差异曲线分析个人决策。</p><p>第二十二章：（微观经济学前言）介绍不对称信息，政治经济学和行为经济学。</p><p><strong>宏观经济学</strong></p><p>第二十三章：讨论国内生产总值和国名收入账户相关的统计数字的含义。</p><p>第二十四章：讨论消费物价指数的衡量与运用。</p><p>第二十五章：考察不同时期与不同国家生活水平差别巨大的决定因素。</p><p>第二十六章：讨论金融机构，考察这些机构在配置资源中的作用。</p><p>第二十七章：介绍现值，风险管理与资产评估。（基本金融工具）</p><p>第二十八章：考察失业率的长期决定因素。（寻找工作，最低工资法，工会的市场势力及效率工资）</p><p>第二十九章：介绍货币概念（经济学家角度），中央银行在控制货币量中的作用。</p><p>第三十章：介绍古典通货膨胀理论，讨论通货膨胀给社会带来的成本。</p><p>第三十一章：1，介绍储蓄，投资与贸易余额之间的关系2，名义和实际汇率之间的区别3，介绍购买力平价理论。</p><p>第三十二章：介绍古典国际物品与资本流动模型。（预算赤字与贸易赤字之间的联系，贸易政策的宏观经济影响）</p><p>第三十三章：介绍总需求与总供给模型。（根据有关经济周期的一些事实）</p><p>第三十四章：解释决策者如何可以移动总需求曲线（利用掌握的工具）。</p><p>第三十五章：1，解释为什么控制总需求的决策者面临通货膨胀与失业的权衡取舍关系2，为什么这种权衡取舍关系存在于短期中3，为什么它会最终消失。</p><p>第三十六章：宏观经济政策的五个争论问题1，政策积极主义的适当程度（对经济周期作出反应）2，规则与相机抉择之间的选择（运用货币政策）3，实现零通货膨胀的合意性4，政府预算平衡的重要性5，为鼓励储蓄进行税收改革的需要</p><p>我们为什么要学习经济学？</p><p>经济学有助于了解自己生活的世界，使个人更加精明的参与经济，还可以更好的理解经济政策的潜力与局限性。</p><p>DAY2：2021年10月9日</p><h1 id="第一章：经济学原理"><a href="#第一章：经济学原理" class="headerlink" title="第一章：经济学原理"></a>第一章：经济学原理</h1><p><strong>稀缺性</strong>：社会拥有的资源是有限的，因此不能生产人们希望拥有的所有物品与劳务。</p><p>经济学研究社会如何管理自己的稀缺资源。</p><p>原理一到四研究的是个人如何做出决策。</p><h2 id="原理一：人们面临权衡取舍"><a href="#原理一：人们面临权衡取舍" class="headerlink" title="原理一：人们面临权衡取舍"></a><strong>原理一：人们面临权衡取舍</strong></h2><p>做出决策要求我们在一个目标与另一个目标之间权衡取舍。</p><p>社会面临的权衡取舍是在效率与平等之间的。</p><p>效率是指社会能从其稀缺资源中得到的更多的东西（经济蛋糕的大小）。</p><p>平等是指将这些资源的成果公平地分配给社会成员（如何分割这块蛋糕）。</p><p>（政府想要把经济蛋糕切为更均等的小块时，这块蛋糕本身也就变小了。）</p><h2 id="原理二：某种东西的成本是为了得到它所放弃的东西"><a href="#原理二：某种东西的成本是为了得到它所放弃的东西" class="headerlink" title="原理二：某种东西的成本是为了得到它所放弃的东西"></a><strong>原理二：某种东西的成本是为了得到它所放弃的东西</strong></h2><p>做出决策就要比较可供选择的行动方案的成本与收益。（但某种行动的成本并不像乍看时那么明显）</p><p>一种东西的机会成本是为了得到这种东西所放弃的东西。</p><h2 id="原理三：理性人考虑边际量"><a href="#原理三：理性人考虑边际量" class="headerlink" title="原理三：理性人考虑边际量"></a><strong>原理三：理性人考虑边际量</strong></h2><p>边际变动：描述对现有行动的微小增量调整。（当考试临近时，我的决策不是在放弃考试或一天学习24个小时之间的选择，而是是否多花一小时复习功课而不是看电视）</p><p>人们通过考虑边际量（边际利益与边际成本）来做出最优决策</p><h2 id="原理四：人们会对激励做出反应"><a href="#原理四：人们会对激励做出反应" class="headerlink" title="原理四：人们会对激励做出反应"></a><strong>原理四：人们会对激励做出反应</strong></h2><p>许多政策改变了人们面临的成本或利益，从而改变了行为。</p><p>不仅应该考虑直接影响，而且还应该考虑通过激励发生的间接影响。</p><p>原理五到七研究的是人们如何相互交易</p><h2 id="原理五：贸易能使每个人状况更好"><a href="#原理五：贸易能使每个人状况更好" class="headerlink" title="原理五：贸易能使每个人状况更好"></a><strong>原理五：贸易能使每个人状况更好</strong></h2><p>贸易使每个人可以专门从事自己最擅长的活动。</p><p>通过与其他人交易，人们可以按较低的成本活获得各种各样的物品与劳务。</p><h2 id="原理六：市场通常是组织经济活动的一种好方法"><a href="#原理六：市场通常是组织经济活动的一种好方法" class="headerlink" title="原理六：市场通常是组织经济活动的一种好方法"></a><strong>原理六：市场通常是组织经济活动的一种好方法</strong></h2><p>市场经济：当许多企业和家庭在物品与劳务市场上相互交易时，通过他们的分散决策配置资源的经济。</p><p>价格就是看不见的手用来指引经济活动的工具。</p><p>价格既反映了一种物品的社会价值，也反映了生产该物品的社会成本。</p><p>重要推论：当政府阻止价格根据供求自发地调整时，它就限制了看不叫的手协调组成经济的千百万家庭和企业的能力。（中央计划经济）</p><p>DAY3：2021年10月10日</p><h2 id="原理七：政府有时可以改善市场效果"><a href="#原理七：政府有时可以改善市场效果" class="headerlink" title="原理七：政府有时可以改善市场效果"></a><strong>原理七：政府有时可以改善市场效果</strong></h2><p>看不见的手需要政府来保护它（只有产权得到保护，市场才能运行）</p><p>“经济参与者受利己所驱动，而市场中‘看不见的手’指引这种利己去促进一般社会福利“——斯密</p><p>政府干预经济的原因有两类：促进效率和促进平等。（大多数政策不是把经济蛋糕做大，而是改变蛋糕的分割）</p><p>市场失灵：市场本身不能有效配置资源的情况。市场失灵的可能原因是外部性和市场势力。</p><p>外部性：一个人的行为对旁观者福利的影响。</p><p>市场势力：一个经济活动者（或经济活动者的一个小集团）对市场价格有显著影响的能力。</p><p>看不见的手不能确保公平地分配经济成果。</p><p>市场经济根据人们生产其他人愿意买的东西的能力来给报酬。</p><p>政府有时可以改善市场结果并不意味着它总能这样。</p><p>原理八到十研究的是整体经济如何运行</p><h2 id="原理八：一国的生活水平取决于它生产物品与劳务的能力"><a href="#原理八：一国的生活水平取决于它生产物品与劳务的能力" class="headerlink" title="原理八：一国的生活水平取决于它生产物品与劳务的能力"></a><strong>原理八：一国的生活水平取决于它生产物品与劳务的能力</strong></h2><p>用生产率的差别解释各国和不同时期中生活水平的巨大差别。</p><p>一国的生产率增长率决定了平均收入增长率。</p><p>在考虑任何一项政策如何影响生活水平时，关键问题是这项政策如何影响我们生产物品与劳务的能力。</p><h2 id="原理九：当政府发行了过多货币时，物价上升"><a href="#原理九：当政府发行了过多货币时，物价上升" class="headerlink" title="原理九：当政府发行了过多货币时，物价上升"></a><strong>原理九：当政府发行了过多货币时，物价上升</strong></h2><p>通货膨胀：经济中物价总水平的上升</p><p>货币量的增加引起通货膨胀。</p><h2 id="原理十：社会面临通货膨胀与失业之间的短期权衡取舍"><a href="#原理十：社会面临通货膨胀与失业之间的短期权衡取舍" class="headerlink" title="原理十：社会面临通货膨胀与失业之间的短期权衡取舍"></a><strong>原理十：社会面临通货膨胀与失业之间的短期权衡取舍</strong></h2><p>增加经济中的货币量→通货膨胀和至少短期内降低失业水平。</p><p>菲利普斯曲线：通货膨胀与失业之间的短期权衡取舍</p><p>菲利普斯曲线有利于理解经济周期</p><p>决策者可以通过改变政府支出量，税收量和发行的货币量来影响经济所经历的通货膨胀与失业的组合。</p><p>DAY4：2021年10月16日</p><p>2021/11/16<br>一个月过去了，计划中道崩殂，因为数学课程的压力太大。</p>]]></content>
    
    
    
    <tags>
      
      <tag>经济学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora基础用法笔记</title>
    <link href="/2021/10/16/typora%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/16/typora%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础的使用语法"><a href="#基础的使用语法" class="headerlink" title="基础的使用语法"></a><strong>基础的使用语法</strong></h1><h2 id="段落与分割线"><a href="#段落与分割线" class="headerlink" title="段落与分割线"></a><strong>段落与分割线</strong></h2><p>使用enter直接切换到下一个段落，而使用shift+enter则切换到下一行(段与段的长度比行与行的长度长)<br>想要在段与段之间添加分割线可以使用***</p><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a><strong>字体</strong></h2><p>加粗:文字前后分别添加”**”<br>斜体:文字前后分别添加” * “<br>删除线:文字前后添加”~~”</p><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a><strong>标题</strong></h2><p>Markdown语法中的标题都是在文字面前使用”#”，前面有几个”#”就是几级标题(文字与#之间需保留空格)</p><hr><h2 id="块"><a href="#块" class="headerlink" title="块"></a><strong>块</strong></h2><p>代码块:将输入法切换至英文，输入”```”即可输入代码<br>公式块:使用快捷键ctrl+shift+M即可出现书写公式界面<br>引用块:将输入法切换为英文，输入符号&gt;再按下空格即可进入引用格式</p><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h2><p>使用typora工具栏中的段落-表格可以自动生成一个表格，左上角的栏目可以用于表格的调试</p><table><thead><tr><th align="left"><strong>这是一个表格</strong></th></tr></thead><tbody><tr><td align="left"><strong>这是表格内容</strong></td></tr></tbody></table><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a><strong>图片</strong></h2><p>直接使用 右键 - 复制 将网络图片、剪贴板图片复制到文档中<br>拖动本地图片到文档中<br>Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题<br>在 文件 - 偏好设置 - 编辑器 - 图像中可以设置图片保存的位置</p><hr><h2 id="打字机模式与专注模式"><a href="#打字机模式与专注模式" class="headerlink" title="打字机模式与专注模式"></a><strong>打字机模式与专注模式</strong></h2><p>打字机模式:使得你所编辑的那一行永远处于屏幕正中<br>专注模式:使你正在编辑的那一行保留颜色，而其他行的字体呈灰色</p><hr><h2 id="大纲-amp-文字侧边栏"><a href="#大纲-amp-文字侧边栏" class="headerlink" title="大纲&amp;文字侧边栏"></a><strong>大纲&amp;文字侧边栏</strong></h2><p>Typora 会根据你 Markdown 标记的 H1、H2、H3…… 各级标题为你呈现一个大纲。</p><hr><h1 id="进阶的使用方法–添加插件"><a href="#进阶的使用方法–添加插件" class="headerlink" title="进阶的使用方法–添加插件"></a>进阶的使用方法–添加插件</h1><p>–随缘更新……</p><hr><blockquote><p><a href="https://www.typora.net/support/">支持 | typora中文网</a><br><a href="https://www.typora.net/1736.html">Typora使用方法教程 | typora中文网</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网站更新日志2021/10/16</title>
    <link href="/2021/10/16/%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%972021-10-16/"/>
    <url>/2021/10/16/%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%972021-10-16/</url>
    
    <content type="html"><![CDATA[<p>/将网站的主题从next更换为了fluid<br>/添加了页面图片<br>/添加了”about”页面更多的信息<br>/持续学习markdown文件编译技术，选择使用typora编译器</p>]]></content>
    
    
    
    <tags>
      
      <tag>更新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2021/10/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/10/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>这是我创建的第一个个人博客，内容应该不会太多。<br>在这里简要的说明一下，我目前还在学习大一基础课程中的程序设计，使用的是C语言编程工具。（菜鸟实锤）<br>建立个人博客主要是兴趣爱好使然，也是想记录分享下自己的学习，生活。（学Web前端技术也是为了能找口饭吃，，，）<br>下面简要的谈谈未来的工作：(学习进度会进行归纳整理并发布）<br>1，熟练应用MarkDown编译器（最基本的文章编写能力）<br>2，熟练规划设计hexo网站（页面美化，标签分类等）<br>3，不停的学习计算机技术！（在保障不挂科的情况下)<br>今天（15号）有幸得到某位大牛的指导：成为大佬很简单，不喊累，再加上强劲的执行力即可。    </p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
