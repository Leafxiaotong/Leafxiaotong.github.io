<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leafxiaotong</title>
  
  <subtitle>Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-06T20:09:58.114Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Leafxiaotong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DataStructure and Database</title>
    <link href="http://example.com/2022/06/07/DataStructure-and-Database/"/>
    <id>http://example.com/2022/06/07/DataStructure-and-Database/</id>
    <published>2022-06-06T20:05:26.000Z</published>
    <updated>2022-06-06T20:09:58.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022春-数据结构与数据库"><a href="#2022春-数据结构与数据库" class="headerlink" title="2022春 数据结构与数据库"></a>2022春 数据结构与数据库</h1><p>数据结构部分</p><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><p>1、了解<strong>数据、数据元素、数据对象、数据结构、数据的逻辑结构和物理结构</strong>等概念；<br><strong>数据</strong>：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整形、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。<br>a.可以输入到计算机中<br>b.能被计算机程序处理<br><strong>数据元素</strong>：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。<br><strong>数据对象</strong>：是性质相同的数据元素的集合，是数据的子集。<br><strong>数据结构</strong>：是相互之间存在一种或者多种特定关系的数据元素的集合。<br><strong>逻辑结构</strong>：人的大脑想像，可以画在纸上，一般分为俩大类线性结构，非线性结构，（同时也可以分为四大类比如具有线性表结构、空关系、树形结构、图形结构。可以把逻辑结构用物理结构（比如顺序存储）在计算机中存储起来。）<br><strong>存储结构</strong>：主要有顺序结构（数组）和非顺序结构（链式存储结构）</p><p>2、了解<strong>抽象数据类型</strong>的概念和用抽象数据类型建模的一般方法<br><strong>抽象数据类型</strong>：定义了一个数据对象、数据对象中各元素之间的结构关系以及一组处理数据的操作（例如抽象数据类型相当于面向对象中的类，数据结构相当于类的实现（一般用户可以自己设定，定义抽象数据类型ADT））</p><p>3、掌握类 C 和 C 之间的差异和用类 C 表达算法的方法</p><p>4、重点掌握算法效率的度量方法，学会分析简单算法的性能。（了解常见函数的增长率）<br>知道怎么运算简单的时间复杂度，空间复杂度。<br>会计算一些语句的频度。</p><h2 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h2><p>1、了解<strong>线性表</strong>的特点及类型定义；<br>线性表是n个数据特性相同的元素的组成有限序列，是最基本且常用的一种线性结构（线性表，栈，队列，串和数组都是线性结构），同时也是其他数据结构的基础。<br>对于<strong>非空的线性表或者线性结构的特点</strong>：<br>（1）存在唯一的一个被称作“第一个”的数据元素；（首项）<br>（2）存在唯一的一个被称作“最后一个”的数据元素；（末项）<br>（3）除第一个外，结构中的每个数据元素均只有一个前驱；（前驱唯一）<br>（4）除最后一个外，结构中的每个数据元素均只有一个后继；（后继唯一）</p><p>2、掌握<strong>线性表的顺序表示及实现和链式表示及实现</strong>（单链表、双向链表和循环链表）；<br>3、算法设计：熟练掌握线性表在顺序存储结构和链式存储结构下的<strong>创建、插入、删除和查找</strong>等基本操作；链表<strong>合并与分解</strong>；有序表的操作方法；<br><strong>顺序表示（顺序表）</strong><br>概念：用一组<strong>地址连续</strong>的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表。<br>特点：<strong>逻辑上相邻的数据元素，物理次序也是相邻的</strong>。<br>只要确定好了存储线性表的起始位置，线性表中任一数据元素都可以<strong>随机存取</strong>，所以线性表的顺序存储结构是一种随机存取的储存结构，因为高级语言中的数组类型也是有随机存取的特性，所以通常我们都使用数组来描述数据结构中的顺序储存结构，用动态分配的一维数组表示线性表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxsize 100 <span class="hljs-comment">//定义学生最大数量</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OK 1       <span class="hljs-comment">//正确标志</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERROR 0     <span class="hljs-comment">//失败标志</span></span><br><span class="hljs-comment">//学生信息的数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> id;   <span class="hljs-comment">//学生id</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">30</span>];   <span class="hljs-comment">//学生姓名</span><br>&#125;Student;<br><span class="hljs-comment">//顺序表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    Student *elem;   <span class="hljs-comment">//储存空间的基地址</span><br>    <span class="hljs-keyword">int</span> length;      <span class="hljs-comment">//数据结构的长度</span><br>&#125;SqList;<br><span class="hljs-comment">//定义SqList类型的变量</span><br>SqList L;<br><span class="hljs-comment">//这样就定义好了一种顺序表</span><br><br><span class="hljs-comment">//初始化顺序表基本算法</span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造一个空的顺序表L   </span><br>    L.elem = <span class="hljs-keyword">new</span> ElemType[maxsize];  <span class="hljs-comment">//分配内存空间</span><br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    L.length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//顺序表插入</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> i,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length+<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//i不合法</span><br>   <span class="hljs-keyword">if</span>(L.length == maxsize) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//满了</span><br>   <span class="hljs-keyword">for</span>(j=L.length<span class="hljs-number">-1</span>;j&gt;=i<span class="hljs-number">-1</span>;j--)<br>   L.elem[j+<span class="hljs-number">1</span>]=L.elem[j]; <span class="hljs-comment">//将第n个至i个位置的元素后移</span><br>   L.elem[i<span class="hljs-number">-1</span>]=e; <span class="hljs-comment">//将e放进第i个位置</span><br>&#125;<br><br><span class="hljs-comment">//顺序表取值</span><br><span class="hljs-function">Status <span class="hljs-title">Get</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> i,ElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length)  <span class="hljs-keyword">return</span> ERROR;<br>   e = L.elem[i<span class="hljs-number">-1</span>];<br>   <span class="hljs-keyword">return</span> OK;     <br>&#125;<br><br><span class="hljs-comment">//顺序表查找</span><br><span class="hljs-function">Status <span class="hljs-title">Find</span><span class="hljs-params">(SqList L,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//查找值为e的数据元素，返回其序号</span><br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;L.length;i++)<br>       &#123;  <br>           <span class="hljs-keyword">if</span>(L.elem[i]==e) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>       &#125;<br>   <span class="hljs-keyword">return</span> ERROR;   <span class="hljs-comment">//查找失败       </span><br>&#125;<br><br><span class="hljs-comment">//顺序表删除</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//删除第i个元素,i的值为[1,L.length]</span><br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length)) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">for</span>(j=i;j&lt;=L.length<span class="hljs-number">-1</span>;j++)<br>    L.elem[j<span class="hljs-number">-1</span>]=L.elem[j];<br>    --L.length;  <span class="hljs-comment">//长度减一</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>链表</strong><br>概念：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的），包括数据域和指针域，<strong>数据域存数据，指针域指示其后继的信息</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//单链表存储结构</span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span></span><br><span class="hljs-class">  &#123;</span><br>      ElemType data;   <span class="hljs-comment">//数据域</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指针域</span><br>  &#125;LNode,*LinkList;<br><span class="hljs-comment">//LinkList与LNode*,本质上两者是等价的。通常习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针，用LNode *定义指向单链表中任意结点的指针变量</span><br><br><span class="hljs-comment">//初始化 </span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//构造一个单链表</span><br>     L=<span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">//生成头结点，用头指针L指向头结点</span><br>     L-&gt;next =<span class="hljs-literal">NULL</span>;  <br>     <span class="hljs-keyword">return</span> OK;    <br>&#125;<br><br><span class="hljs-comment">//取值</span><br><span class="hljs-function">Status <span class="hljs-title">Get</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i,ElemType &amp;e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在带头结点的单链表L中根据序号I获取元素的值，用e返回L中第i个数据元素的值</span><br>    p=L-&gt;next;<br>    j=<span class="hljs-number">1</span>;<span class="hljs-comment">//计数器</span><br>    <span class="hljs-keyword">while</span>(p&amp;&amp;j&lt;i)     <span class="hljs-comment">//顺着链表向后扫描，直到j==i</span><br>    &#123;<br>        p=p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p||j&gt;i) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//不合法</span><br>    e=p-&gt;data;   <span class="hljs-comment">//找到该结点后获取该结点的数据域</span><br>    <span class="hljs-keyword">return</span> OK; <br>&#125;<br><br><span class="hljs-comment">//查找</span><br><span class="hljs-function">LNode *<span class="hljs-title">Find</span><span class="hljs-params">(LinkList L,ElemType e)</span></span><br><span class="hljs-function"> </span>&#123;<br>     p=L-&gt;next; <span class="hljs-comment">//使p指向首元结点</span><br>     <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data!=e)<br>     &#123;<br>         p=p-&gt;next;  <span class="hljs-comment">//不符合条件就一直滚下去</span><br>     &#125;<br>     <span class="hljs-keyword">return</span> p;   <span class="hljs-comment">//这里有两种情况，找到的时候返回指针p，如果找不到那么这个p则为null,因为最后一个指向的是null</span><br>&#125;<br><br><span class="hljs-comment">//插入</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i,ElemType e)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//在带头结点的单链表L中第i个位置插入值为e的新结点</span><br>    p=L;j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p&amp;&amp;(j&lt;i<span class="hljs-number">-1</span>))<br>    &#123;<br>        p=p-&gt;next;         <span class="hljs-comment">//查找第i-1个结点，p指向该结点</span><br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p||j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR;<br>    s=<span class="hljs-keyword">new</span> LNode;   <span class="hljs-comment">//生成一个新结点</span><br>    s-&gt;data=e;   <span class="hljs-comment">//将结点*s的数据域置为e</span><br>    s-&gt;next=p-&gt;next; <span class="hljs-comment">//先接尾部</span><br>    p-&gt;next=s;  <span class="hljs-comment">//再接头部</span><br>&#125;<br><br><span class="hljs-comment">//删除</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//删除第i个元素</span><br>    p=L;j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((p-&gt;next)&amp;&amp;(j&lt;i<span class="hljs-number">-1</span>))<br>    &#123;<br>        p=p-&gt;next;    <span class="hljs-comment">//查找i-1个结点</span><br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next)||(j&gt;i<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//当i&gt;n或i&lt;1时，不符合条件</span><br>    q=p-&gt;next;   <span class="hljs-comment">//临时保存被删除的地址</span><br>    p-&gt;next=q-&gt;next;  <span class="hljs-comment">//将前驱结点指向后驱</span><br>    <span class="hljs-keyword">delete</span> q;  <span class="hljs-comment">//释放删除结点的空间</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//前插法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateList</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"> </span>&#123;<span class="hljs-comment">//逆次序输出n个元素的值</span><br>     L=<span class="hljs-keyword">new</span> LNode;<br>     L-&gt;next=<span class="hljs-literal">NULL</span>;<br>     <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>     &#123;<br>         p=<span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">//生成新结点</span><br>         cin&gt;&gt;p-&gt;data;  <span class="hljs-comment">//输入新结点的数据域内容</span><br>         p-&gt;next=L-&gt;next; <span class="hljs-comment">//将新结点插到头结点之后</span><br>         L-&gt;next=p;<br>     &#125;<br> &#125;<br><br> <span class="hljs-comment">//后插法</span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateList</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"> </span>&#123;<span class="hljs-comment">//正次序输入n个元素的值</span><br>     L=<span class="hljs-keyword">new</span> LNode;<br>     L-&gt;next=<span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//建立一个带头结点的空链表</span><br>     r=L;   <span class="hljs-comment">//尾指针r指向头结点</span><br>     <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>     &#123;<br>         p=<span class="hljs-keyword">new</span> LNode; <span class="hljs-comment">//生成新结点</span><br>         cin&gt;&gt;p-&gt;data; <span class="hljs-comment">//输入新结点的数据域内容</span><br>         p-&gt;next=<span class="hljs-literal">NULL</span>;<br>         r-&gt;next=p;  <span class="hljs-comment">//将新结点插入尾结点之后</span><br>         r=p;   <span class="hljs-comment">//改变尾指针，使其指向新的尾结点</span><br>     &#125;<br> &#125;<br><span class="hljs-comment">//重点掌握前插法与后插法</span><br></code></pre></td></tr></table></figure><h2 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h2><p>1、了解<strong>栈的定义及特点</strong>，掌握<strong>栈表示和实现</strong>，重点是<strong>栈初始化、判断栈空和栈满、出栈和 入栈操作</strong>；<br>栈(stack)是限定仅在表尾进行插入或者删除的线性表。对于栈来说，表尾端称为栈顶（top），表头端称为栈底（bottom）。不含元素的空表称为空栈。因为栈限定在表尾进行插入或者删除，所以栈又被称为后进先出的线性表（简称LIFO:Last in, First out.结构）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>SDataType *base; <span class="hljs-comment">//栈底指针</span><br>SDataType *top;  <span class="hljs-comment">//栈顶指针</span><br><span class="hljs-keyword">int</span> StackSize;   <span class="hljs-comment">//当前已经分配的存储空间，以元素为单位 </span><br>&#125;SqStack;<br><br><span class="hljs-comment">//初始化顺序栈，构造一个空栈</span><br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br><span class="hljs-comment">//分配存储空间 </span><br>S.base = (SDataType *)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(SDataType));<br><span class="hljs-keyword">if</span>(!S.base)&#123;<br><span class="hljs-comment">//如果分配失败，则返回error </span><br><span class="hljs-keyword">return</span> OVERFLOW;<br>&#125;<br><span class="hljs-comment">//S.top 始终指向栈顶元素的下一个位置 </span><br>S.top = S.base;    <span class="hljs-comment">//初始状态下为空栈 </span><br>S.StackSize = STACK_INIT_SIZE;   <span class="hljs-comment">//当前已经分配的存储容量为100个 </span><br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//判断是否为空栈</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">judgeNull</span><span class="hljs-params">(SqStack &amp;s)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s.top == s.base)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;此栈为空栈！\n&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;此栈不为空栈！\n&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//判断是否为满栈</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">judgeFull</span><span class="hljs-params">(SqStack &amp;s)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s.top-s.base == s.StackSize)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈满！\n&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈未满！\n&quot;</span>);<br>&#125; <br>&#125;<br><br><span class="hljs-comment">//入栈</span><br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;s,SDataType e)</span></span>&#123;<br>SDataType *p;<br><span class="hljs-comment">//首先判断栈是不是满的（上溢） </span><br><span class="hljs-keyword">if</span>(s.top-s.base == s.StackSize)&#123;<br><span class="hljs-comment">//追加空间 </span><br>p = (SDataType *)<span class="hljs-built_in">realloc</span>(s.base,(STACK_INIT_SIZE+STACKINCREMENT)*<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(SDataType));<br><span class="hljs-keyword">if</span>(!p)&#123;<br><span class="hljs-comment">//如果没有找到符合条件的存储空间，则返回error </span><br><span class="hljs-keyword">return</span> OVERFLOW;<br>&#125;<br><span class="hljs-comment">//成功找到则使s.base指向p </span><br>s.base = p;<br>s.top = s.base + s.StackSize;<br>s.StackSize +=  STACKINCREMENT;<br>&#125;<br><span class="hljs-comment">//先插入元素，然后将栈顶指针加 1 </span><br>*(s.top) = e;<br>s.top++;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//出栈</span><br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;s,SDataType &amp;e)</span></span>&#123;<br><span class="hljs-comment">//判断是否会发生下溢 </span><br><span class="hljs-keyword">if</span>(s.top != s.base)&#123;<br>s.top--;    <span class="hljs-comment">//先将栈顶指针减 1 </span><br>e = *(s.top);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、栈的应用举例，重点是<strong>表达式求值</strong>（了解<strong>波兰式、逆波兰式、中缀式</strong>等概念）；<br><strong>中缀表达式</strong>得名于它是由相应的语法树的<strong>中序遍历</strong>的结果得到的。<br><strong>前缀表达式</strong>又叫做<strong>波兰式</strong>。同样的道理，表达式的前缀表达式是由相应的语法树的前序遍历的结果得到的。<br><strong>后缀表达式</strong>又叫做<strong>逆波兰式</strong>。它是由相应的语法树的后序遍历的结果得到的。<br><img src="/.com//Blog\source\_posts\DataStructure-and-Database\2.png" alt="2"></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">中缀表达：<span class="hljs-selector-tag">A</span>+<span class="hljs-selector-tag">B</span>*(C-D)<span class="hljs-selector-tag">-E</span>*<span class="hljs-selector-tag">F</span><br>前缀表达：<span class="hljs-selector-tag">-</span>+<span class="hljs-selector-tag">A</span>*<span class="hljs-selector-tag">B</span><span class="hljs-selector-tag">-CD</span>*<span class="hljs-selector-tag">EF</span><br>后缀表达：<span class="hljs-selector-tag">ABCD-</span>*+<span class="hljs-selector-tag">EF</span>*<span class="hljs-selector-tag">-</span><br></code></pre></td></tr></table></figure><p>3、<strong>栈与递归</strong>的实现（系统工作栈的原理）；</p><p>4、了解<strong>队列的定义及特点</strong>，掌握<strong>队列的表示和实现</strong>，重点是<strong>循环队列</strong>。<br>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<br>队列是一种<strong>先进先出（First In First Out）</strong>的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。<br>队头（Front）：允许删除的一端，又称队首。<br>队尾（Rear）：允许插入的一端。<br>空队列：不包含任何元素的空表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 50<span class="hljs-comment">//定义队列中元素的最大个数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>ElemType data[MAXSIZE];<span class="hljs-comment">//存放队列元素</span><br><span class="hljs-keyword">int</span> front,rear;<br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p><strong>把队列的这种头尾相接的顺序存储结构称为循环队列。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*初始时：Q-&gt;front = Q-&gt;rear=0。</span><br><span class="hljs-comment">队首指针进1：Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE。</span><br><span class="hljs-comment">队尾指针进1：Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE。</span><br><span class="hljs-comment">队列长度：(Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE。*/</span><br></code></pre></td></tr></table></figure><p><img src="/.com//Blog\source\_posts\DataStructure-and-Database\3.png" alt="3"><br>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是种较为普遍的做法，约定以“队头指针在队尾指针的下一位置作为队满的标志”，如图 ( d2 )所示。    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*队满条件： (Q-&gt;rear + 1)%Maxsize == Q-&gt;front</span><br><span class="hljs-comment">队空条件仍： Q-&gt;front == Q-&gt;rear</span><br><span class="hljs-comment">队列中元素的个数： (Q-&gt;rear - Q -&gt;front + Maxsize)% Maxsize*/</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//循环队列的实现</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;   <span class="hljs-comment">//ElemType的类型根据实际情况而定，这里假定为int</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 50  <span class="hljs-comment">//定义元素的最大个数</span></span><br><span class="hljs-comment">/*循环队列的顺序存储结构*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MAXSIZE];<br>    <span class="hljs-keyword">int</span> front;  <span class="hljs-comment">//头指针</span><br>    <span class="hljs-keyword">int</span> rear;   <span class="hljs-comment">//尾指针,若队列不空，指向队列尾元素的下一个位置</span><br>&#125;SqQueue;<br><br><span class="hljs-comment">/*初始化一个空队列Q*/</span><br><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue *Q)</span></span>&#123;<br>    Q-&gt;front = <span class="hljs-number">0</span>;<br>    Q-&gt;rear = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">/*判队空*/</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*返回Q的元素个数，也就是队列的当前长度*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;<br>&#125;<br><br><span class="hljs-comment">/*若队列未满，则插入元素e为Q新的队尾元素*/</span><br><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue *Q, ElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q-&gt;real + <span class="hljs-number">1</span>) % MAXSIZE == Q-&gt;front)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;   <span class="hljs-comment">//队满</span><br>    &#125;<br>    Q-&gt;data[Q-&gt;rear] = e;   <span class="hljs-comment">//将元素e赋值给队尾</span><br>    Q-&gt;rear = (Q-&gt;rear + <span class="hljs-number">1</span>) % MAXSIZE;  <span class="hljs-comment">//rear指针向后移一位置，若到最后则转到数组头部</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">/*若队列不空，则删除Q中队头元素，用e返回其值*/</span><br><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue *Q, ElemType *e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>(Q))&#123;<br>        <span class="hljs-keyword">return</span> REEOR;   <span class="hljs-comment">//队列空的判断</span><br>    &#125;<br>    *e = Q-&gt;data[Q-&gt;front]; <span class="hljs-comment">//将队头元素赋值给e</span><br>    Q-&gt;front = (Q-&gt;front + <span class="hljs-number">1</span>) % MAXSIZE;    <span class="hljs-comment">//front指针向后移一位置，若到最后则转到数组头部</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第五章-多维数组"><a href="#第五章-多维数组" class="headerlink" title="第五章 多维数组"></a>第五章 多维数组</h2><p>1、了解<strong>数组的定义</strong>，数组<strong>行主序和列主序</strong>的排列方式和顺序表示；</p><p>2、了解特殊矩阵的<strong>压缩存储表示</strong>和<strong>下标变换</strong>;</p><p>3、了解稀疏矩阵的定义和表示：<strong>三元组表和十字链表</strong>。</p><h2 id="第六章-树与二叉树"><a href="#第六章-树与二叉树" class="headerlink" title="第六章 树与二叉树"></a>第六章 树与二叉树</h2><p>1、了解<strong>树的定义和基本术语</strong>；<br>树：树状图是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：<br>每个节点有零个或多个子节点；<br>没有父节点的节点称为<strong>根节点</strong>；<br>每一个非根节点有且只有一个父节点；<br>除了根节点外，每个子节点可以分为多个不相交的子树；<br><strong>基本术语</strong>：<br>节点：节点包括一个数据元素及若干指向其他子树的分支。<br>节点的度：节点所拥有子树的个数称为节点的度。<br>叶节点：度为0的节点成为叶结点，叶结点也称为终端节点。<br>分支节点：度不为0的节点称为分支节点，分支节点又称非终端节点。一棵树中排除叶结点外的所有节点都是分支节点。<br>祖先节点：从根节点到该节点所经分支上的所有节点。<br>子孙节点：以某节点为根节点的子树中所有节点<br>双亲节点：树中某节点有孩子节点，则这个节点称为它孩子节点的双亲节点，双亲节点也成为前驱节点。<br>孩子节点：树中一个节点的子树的根节点称为该节点的孩子节点，孩子节点也称为后继节点。<br>兄弟节点：具有相同双亲节点的节点称为兄弟节点。<br>树的度：树中所有节点的度的最大值成为该树的度。<br>节点的层次：从根节点到树中某节点所经路径上的分支也称为该节点的层次，根节点的层次为1，其他节点层次是双亲节点层次加1.<br>树的深度：树中所有节点的层次的最大值称为该树的深度。<br><strong>树的简单性质</strong><br>1)树中的结点数等于所有结点的度数加1.<br>2)度为m的树中第i层上至多有m^(i-1)个结点(i&gt;=1)。<br>3)高度为h的m叉树至多有(m^h-1)/ (m - 1) 个结点”。<br>4)具有n个结点的m又树的最小高度为㏒m (n(m -1)+ 1)</p><p>2、掌握<strong>二叉树的定义、性质和表示</strong>；<br>二叉树的定义：二叉树，就是度不差过2的树（节点最多有两个分杈）。<br>二又树是另一种树形结构， 其特点是每个结点至多只有两棵子树 (即二叉树中不存在度大于2的结点)。并且<strong>二叉树的子树有左右之分，其次序不能任意顺倒</strong>。<br>五种<strong>基本形态</strong>：<br>1、 空二叉树（什么都没有，nothing）<br>2、 只有一个根节点的二叉树（左右子树为空）<br>3、 右子树为空的二叉树（右腿断了）<br>4、 左子树为空的二叉树（左腿断了）<br>5、 左右子树都非空的的二叉树（既有左子树又有右子树）<br><strong>二叉树的简单性质</strong><br>性质1：二叉树第i层上的结点数目最多为2^（i-1）(i&gt;=1)<br>性质2：深度为k的二叉树至多有2^k - 1个结点（k&gt;=1）<br>性质3：包含n个结点的二叉树的高度至少为(log2n)+1<br>性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span></span><br><span class="hljs-class">&#123;</span><br>    TElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左右孩子指针</span><br>&#125; BiTNode, *BiTree;<br><br><span class="hljs-function">Status <span class="hljs-title">InitBiTree</span><span class="hljs-params">(BiTree &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> value;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;value);<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-comment">//当输入#时，代表该处为空树</span><br>    &#123;<br>        T = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> OK;<br>    &#125;<br>    T = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTNode)); <span class="hljs-comment">//调用malloc动态分配内存</span><br>    <span class="hljs-keyword">if</span> (!T)<br>        <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//分配失败则报错</span><br>    T-&gt;data = value;<br>    <span class="hljs-built_in">InitBiTree</span>(T-&gt;lchild); <span class="hljs-comment">//递归定义</span><br>    <span class="hljs-built_in">InitBiTree</span>(T-&gt;rchild);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">DestroyBiTree</span><span class="hljs-params">(BiTree &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (T-&gt;lchild != <span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">DestroyBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">DestroyBiTree</span>(T-&gt;rchild);<br>    &#125;        <span class="hljs-comment">//递归函数</span><br>    <span class="hljs-built_in">free</span>(T); <span class="hljs-comment">//直接销毁二叉链表</span><br>    T = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、算法设计：<strong>遍历二叉树及应用（先/中/后序遍历的递归算法，层次遍历）</strong>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">PreOrder</span><span class="hljs-params">(BiTree T, Status (*visit)(TElemType e))</span></span><br><span class="hljs-function"><span class="hljs-comment">//先序遍历二叉链树，使用visit依次访问</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (T)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">visit</span>(T-&gt;data))<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PreOrder</span>(T-&gt;lchild, visit))<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PreOrder</span>(T-&gt;rchild, visit))<br>                    <span class="hljs-keyword">return</span> OK;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">InOrder</span><span class="hljs-params">(BiTree T, Status (*visit)(TElemType e))</span></span><br><span class="hljs-function"><span class="hljs-comment">//中序遍历二叉链树，使用visit依次访问</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (T)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">InOrder</span>(T-&gt;lchild, visit))<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">visit</span>(T-&gt;data))<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">InOrder</span>(T-&gt;rchild, visit))<br>                    <span class="hljs-keyword">return</span> OK;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">PostOrder</span><span class="hljs-params">(BiTree T, Status (*visit)(TElemType e))</span></span><br><span class="hljs-function"><span class="hljs-comment">//后序遍历二叉链树，使用visit依次访问</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (T)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PostOrder</span>(T-&gt;lchild, visit))<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PostOrder</span>(T-&gt;rchild, visit))<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">visit</span>(T-&gt;data))<br>                    <span class="hljs-keyword">return</span> OK;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    BiTree vec[MaxSize]; <span class="hljs-comment">//辅助队列,指针数组</span><br>    <span class="hljs-keyword">int</span> front, rear;     <span class="hljs-comment">//设置队首与队尾</span><br>&#125;;<br><br><span class="hljs-function">Status <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiTree T, Status (*visit)(TElemType e))</span></span><br><span class="hljs-function"><span class="hljs-comment">//层序遍历二叉链树，使用visit依次访问(借助队列)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">q</span>;</span><br>    q.front = <span class="hljs-number">0</span>;<br>    q.rear = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">visit</span>(T-&gt;data);<br>        q.vec[++q.rear] = T;     <span class="hljs-comment">//插入队列</span><br>        <span class="hljs-keyword">while</span> (q.rear &gt; q.front) <span class="hljs-comment">//若队列不空</span><br>        &#123;<br>            T = q.vec[++q.front]; <span class="hljs-comment">//取队首</span><br>            <span class="hljs-keyword">if</span> (T-&gt;lchild != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-built_in">visit</span>(T-&gt;lchild-&gt;data);<br>                q.vec[++q.rear] = T-&gt;lchild;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (T-&gt;rchild != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-built_in">visit</span>(T-&gt;rchild-&gt;data);<br>                q.vec[++q.rear] = T-&gt;rchild;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、理解<strong>树和森林的定义、表示</strong>，掌握<strong>森林与二叉树的转换以及森林的遍历</strong>（重点是<strong>孩子兄弟链表</strong>）；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//孩子兄弟表示法，又称二叉树表示法或二叉链表表示法。两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为firstchild域和nextsibling域</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span>&#123;</span><br>    Elemtype data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span> *<span class="hljs-title">firstchild</span>,*<span class="hljs-title">nextsibling</span>;</span><br>&#125;CSNode,*CSTree;<br></code></pre></td></tr></table></figure><p>树的先根遍历即森林的先序遍历可对应到二叉树的先序遍历，树的后根遍历即森林的中序遍历可对应到二叉树的中序遍历。换句话说，若以孩子-兄弟链表作树（或森林）的存储结构，则树的先根遍历（或森林的先序遍历）的算法和二叉树的先序遍历算法类似，而树的后根遍历（或森林的中序遍历）的算法和二叉树的中序遍历算法类似。<br><strong>树的先根对应二叉树的先序，树的后根对应二叉树的中序</strong><br><strong>森林的先序对应二叉树的先序，森林的中序对应二叉树的中序</strong></p><p>5、了解<strong>哈夫曼树的定义、构造及其应用</strong>（即哈夫曼编码）。</p><p>哈夫曼树（最优二叉树）<br>目的：找出存放一串字符所需的最少的二进制编码<br><strong>路径</strong>： 树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。<br><strong>路径长度</strong>：路径上的<strong>分枝数目</strong>称作路径长度。<br><strong>树的路径长度</strong>：从树根到每一个结点的路径长度之和。<br><strong>结点的带权路径长度</strong>：在一棵树中，如果其结点上附带有一个权值，通常把该结点的路径长度与该结点上的权值之积称为该结点的带权路径长度（WPL）</p><p>根据哈弗曼树的定义，一棵二叉树要<strong>使其WPL值最小</strong>，必须<strong>使权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点。</strong><br><img src="/.com//Blog\source\_posts\DataStructure-and-Database\4.png" alt="4"><br><img src="/.com//Blog\source\_posts\DataStructure-and-Database\5.png" alt="5"></p><p>哈夫曼树的应用例之一——<strong>电文传输</strong><br>在电文传输中，需要将电文中出现的每个字符进行二进制编码。在设计编码时需要遵守两个原则：<br>（1）发送方传输的二进制编码，到接收方解码后必须具有唯一性，即解码结果与发送方发送的电文完全一样；<br>（2）发送的二进制编码尽可能地短。下面我们介绍两种编码的方式。</p><ol><li><p><strong>等长编码</strong></p><pre><code>这种编码方式的特点是每个字符的编码长度相同（编码长度就是每个编码所含的二进制位数）。假设字符集只含有4个字符A，B，C，D，用二进制两位表示的编码分别为00，01，10，11。若现在有一段电文为：ABACCDA，则应发送二进制序列：00010010101100，总长度为14位。当接收方接收到这段电文后，将按两位一段进行译码。这种编码的特点是译码简单且具有唯一性，但编码长度并不是最短的。</code></pre></li><li><p><strong>不等长编码</strong></p><pre><code>在传送电文时，为了使其二进制位数尽可能地少，可以将每个字符的编码设计为不等长的，使用频度较高的字符分配一个相对比较短的编码，使用频度较低的字符分配一个比较长的编码。例如，可以为A，B，C，D四个字符分别分配0，00，1，01，并可将上述电文用二进制序列：000011010发送，其长度只有9个二进制位，但随之带来了一个问题，接收方接到这段电文后无法进行译码，因为无法断定前面4个0是4个A，1个B、2个A，还是2个B，即译码不唯一，因此这种编码方法不可使用。</code></pre></li></ol><p>因此，为了设计长短不等的编码，以便减少电文的总长，还必须考虑编码的唯一性，即在建立不等长编码时必须使任何一个字符的编码都不是另一个字符的前缀，这宗编码称为前缀编码（prefix  code）<br>（1）利用字符集中每个字符的<strong>使用频率作为权值</strong>构造一个哈夫曼树；<br>（2）从根结点开始，为到每个叶子结点路径上的<strong>左分支赋予0，右分支赋予1</strong>，并从根到叶子方向形成该叶子结点的编码</p><h2 id="第七章-图"><a href="#第七章-图" class="headerlink" title="第七章 图"></a>第七章 图</h2><p>1、了解<strong>图的定义和术语</strong>；<br><strong>图</strong>（Graph）——图G是由两个集合V（G）和E（G）组成的，记为G=(V,E)<br>其中：V（G）是顶点的非空有限集<br>           E（G）是边的有限集合，边是顶点的无序对(u,v)或有序对<u,v><br><strong>有向图</strong>——有向图G是由两个集合V（G）和E（G）组成的<br>其中：V（G）是顶点的非空有限集<br>           E（G）是有向边（也称弧）的有限集合，弧是顶点的有序对，记为<v,w>，v,w是顶点，v为弧尾，w为弧头<br><strong>无向图</strong>——无向图G是由两个集合V（G）和E（G）组成的<br>其中：V（G）是顶点的非空有限集<br>           E（G）是边的有限集合，弧是顶点的无序对，记为(v,w)或(w,v),并且(v,w)=(w,v)<br><strong>有向完全图</strong>——有n(n-1)条弧的n个顶点的有向图<br><strong>无向完全图</strong>——有n(n-1)/2条边的n个顶点的无向图<br><strong>稀疏图</strong>——若边或弧的个数e&lt;nlogn，则称作稀疏图，否则称稠密图<br><strong>权</strong>——把图的边或弧赋予一个有意义的数，此数称为权<br><strong>带权图-网</strong>——弧或边带权的图分别称为有向网或无向网<br><strong>$子图——如果图G（V,E）和图G<code>（V</code>，E<code>）,满足：V</code>是V的子集，E<code>是E的子集,则称G</code>为G的子图$</strong><br>邻接点——若无向图G中存在(V,W)，则称V,W互为邻接点；边（V,W）的顶点V,W相关联<br><strong>顶点的度</strong><br>无向图中，顶点的度为与该顶点相连的边数<br>有向图中，顶点的度分别为入度与出度<br><strong>入度</strong>：以该顶点为弧头的弧的数目<br><strong>出度</strong>：以该顶点为弧尾的弧的数目<br><strong>路径</strong>：在图G=(V,E)中，若从顶点$v<em>i$出发，沿一些边经过一些顶点$v</em>{p1},v<em>{p2},…,v</em>{pm}$到达顶点$v<em>j$。则成顶点序列$(v_iv</em>{p1}v<em>{p2}…v</em>{pm}v<em>j)$为从顶点$v_i$到顶点$v_j$的路径。它经过的边$(v_i,v</em>{p1})、(v<em>{p1},v</em>{p2})、…、(v_{pm},v_j)$应当是属于E的边<br><strong>路径长度</strong>：非带权图的路径长度是指此路径上边的条数，带权图的路径长度是指路径上各边的权之和<br><strong>简单路径</strong>：路径上各顶点$v_1,v_2,…,v_m$均不互相重复<br><strong>回路</strong>：若路径上第一个顶点$v_1$与最后一个顶点$v_m$重合，则称这样的路径为回路或环<br><strong>简单回路</strong>：图的顶点序列中，除了第一个顶点和最后一个顶点相同外，其余顶点不重复出现的回路叫简单回路<br><strong>连通图</strong>：在无向图中，若从顶点$v_i$到顶点$v_j$有路径，则称顶点$v_i$与$v_j$是连通的，如果图中任意一对顶点都是连通的，则称此图是连通图。<br><strong>连通分量</strong>：非连通图的极大连通子图<br><strong>强连通图</strong>：在有向图中，若对于每一对顶点$v_i$和$v_j$，都存在一条从$v_i$到$v_j$和$v_j$到$v_i$的路径，则称此图为强连通图<br><strong>强连通分量</strong>：非强连通图的极大强连通子图</v,w></u,v></p><p>2、了解<strong>图的数组表示和邻接表表示</strong>；<br>邻接矩阵实现：用<strong>两个数组</strong>分别存储顶点信息和顶点之间的关系信息（邻接矩阵——表示顶点间相邻关系的矩阵）<br>邻接表实现：为图中每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点$V_i$的边（有向图中指以$V_i$为尾的弧）；同时为每一个单链表附设一个表头结点，并将所有的表头结点顺序存储（数组），以便随机访问任一顶点的链表</p><p>3、算法设计：重点<strong>掌握图的遍历算法</strong>；<br>深度优先遍历算法实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Boolean visited[MAX];<span class="hljs-comment">//访问标志数组</span><br><span class="hljs-built_in">Status</span> (*VisitFunc)(<span class="hljs-keyword">int</span> v);<span class="hljs-comment">//函数变量</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFSTraverse</span><span class="hljs-params">(Graph G,Status(*Visit)(<span class="hljs-keyword">int</span> v))</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//对图G作深度优先遍历</span><br>    VisitFunc=Visit;<span class="hljs-comment">//使用全局变量VisitFunc，使DFS不必设函数指针参数</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;G.vexnum;++v)visited[v]=FALSE;<span class="hljs-comment">//访问标志数组初始化</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;G.vexnum;v++)<br>        <span class="hljs-keyword">if</span>(!visited[v])<span class="hljs-built_in">DFS</span>(G,v);<span class="hljs-comment">//对尚未访问的顶点调用DFS</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph G,<span class="hljs-keyword">int</span> v)</span></span>&#123;<br>    <span class="hljs-comment">//从第v个顶点出发递归地深度优先遍历图G。</span><br>    visited[v]=TRUE;<span class="hljs-built_in">VisitFunc</span>(v);<span class="hljs-comment">//访问第v个顶点</span><br>    <span class="hljs-keyword">for</span>(w=<span class="hljs-built_in">FirstAdjVex</span>(G,v);w&gt;=<span class="hljs-number">0</span>;w=<span class="hljs-built_in">NextAdjVex</span>(G,v,w))<br>        <span class="hljs-keyword">if</span>(!visited[w])<span class="hljs-built_in">DFS</span>(G,w);<span class="hljs-comment">//对v的尚未访问的邻接顶点w递归调用DFS</span><br>&#125;<br></code></pre></td></tr></table></figure><p>广度优先遍历算法实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QElemType int <span class="hljs-comment">//队列存储边的位置下标</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span></span><br><span class="hljs-class">&#123;</span><br>    QElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>&#125; QNode, *Qlink;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFSTraverse</span><span class="hljs-params">(Graph G,Status(*Visit)(<span class="hljs-keyword">int</span> v))</span></span>&#123;<br>    <span class="hljs-comment">//按广度优先非递归遍历图G。使用辅助队列Q和访问标志数组visited</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;G.vexnum;v++)visited[v]=FALSE;<br>    <span class="hljs-built_in">InitQueue</span>(Q);<span class="hljs-comment">//置空的辅助队列Q</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;G.vexnum;v++)<br>        <span class="hljs-keyword">if</span>(!visited[v])&#123;<span class="hljs-comment">//v尚未访问</span><br>            visited[v]=TRUE;<span class="hljs-built_in">Visit</span>(v);<br>            <span class="hljs-built_in">EnQueue</span>(Q,v);<span class="hljs-comment">//v入队列</span><br>            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(Q))&#123;<br>                <span class="hljs-built_in">DeQueue</span>(Q,u);<span class="hljs-comment">//队头元素出队并置为u</span><br>                <span class="hljs-keyword">for</span>(w=<span class="hljs-built_in">FirstAdjVex</span>(G,u);w&gt;=<span class="hljs-number">0</span>;w=<span class="hljs-built_in">NextAdjVex</span>(G,u,w))<br>                    <span class="hljs-keyword">if</span>(!Visited[w])&#123;<span class="hljs-comment">//w为u的尚未访问的邻接顶点</span><br>                        Visited[W]=TRUE;<span class="hljs-built_in">Visit</span>(w);<br>                        <span class="hljs-built_in">EnQueue</span>(Q,w);<br>                    &#125;<span class="hljs-comment">//if</span><br>            &#125;<span class="hljs-comment">//while</span><br>        &#125;<span class="hljs-comment">//if</span><br>&#125;<span class="hljs-comment">//BFSTraverse</span><br></code></pre></td></tr></table></figure><p>4、了解<strong>深度优先生成树和广度优先生成树</strong>的概念；<br>对图的遍历过程中，经历的顶点与边就可以构成对应的生成树：<br><img src="/.com//Blog\source\_posts\DataStructure-and-Database\6.png" alt="6"></p><p>深度优先遍历树为：<br><img src="/.com//Blog\source\_posts\DataStructure-and-Database\7.png" alt="7"></p><p>广度优先遍历树为：<br><img src="/.com//Blog\source\_posts\DataStructure-and-Database\8.png" alt="8"></p><p>5、了解<strong>最小生成树的普里姆算法和克鲁斯卡尔算法思想</strong>；<br><strong>最小生成树</strong><br>现在假设有一个很实际的问题：我们要在n个城市中建立一个通信网络，则连通这n个城市需要布置n-1一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？<br>于是我们就可以引入连通图来解决我们遇到的问题，n个城市就是图上的n个顶点，然后，边表示两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有n个顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。<br>构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：<strong>MST性质</strong>（假设N=(V,{E})是一个连通网，U是顶点集V的一个非空子集，如果（u，v）是一条具有最小权值的边，其中u属于U，v属于V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使用MST性质生成最小生成树的算法：<strong>普里姆算法和克鲁斯卡尔算法</strong>。</p><p><strong>普里姆算法—Prim算法</strong><br>算法思路：<br>首先就是从图中的一个起点a开始，把a加入U集合，然后，寻找从与a有关联的边中，权重最小的那条边并且该边的终点b在顶点集合：（V-U）中，我们也把b加入到集合U中，并且输出边（a，b）的信息，这样我们的集合U就有：{a,b}，然后，我们寻找与a关联和b关联的边中，权重最小的那条边并且该边的终点在集合：（V-U）中，我们把c加入到集合U中，并且输出对应的那条边的信息，这样我们的集合U就有：{a,b,c}这三个元素了，一次类推，直到所有顶点都加入到了集合U。</p><p><strong>克鲁斯卡算法—Kruskal算法</strong><br>算法思路：<br>（1）将图中的所有边都去掉。<br>（2）将边按权值从小到大的顺序添加到图中，保证添加的过程中<strong>不会形成环</strong><br>（3）重复上一步直到连接所有顶点，此时就生成了最小生成树。这是一种贪心策略。</p><p>6、了解<strong>有向无环图</strong>，了解<strong>拓扑排序</strong>的算法思想；<br><strong>有向无环图</strong>（简称DAG图，是用来描述一项工程或系统的进行过程的有效工具。）<br><strong>AOV网</strong>：用顶点表示活动，用弧表示活动间的优先关系的有向图称为AOV网，是无权有向无环图<br><strong>AOE网</strong>：用顶点表示事件，弧表示活动权表示活动持续的时间称为AOE网，是带权有向无环图<br><strong>拓扑排序</strong>：将AOV网中<strong>所有顶点按流程次序排成一个线性序列</strong>，该线性序列并不唯一，其过程为：<br>(1)在有向图中<strong>选一个无前驱</strong>的顶点且输出它<br>(2)从图中<strong>删除该顶点和并清除以它为前驱的入度</strong><br>(3)重复一、二步骤，直至<strong>不存在无入度为0的顶点</strong><br>(4)若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环，否则输出的顶点序列即为一个拓扑序列。</p><p>7、了解<strong>最短路径的迪杰斯特拉算法思想</strong>；<br>迪杰斯特拉（dijkstra）算法是<strong>单源最短路径问题</strong>的求解方法。单源最短路径就在给出一个固定网络，<strong>指定一个原点s</strong>，一个目标点e，求这两个点之间的最短路径。</p><h2 id="第九章-查找"><a href="#第九章-查找" class="headerlink" title="第九章 查找"></a>第九章 查找</h2><p>1、<strong>静态查找表（顺序、折半、索引表）</strong><br>查找表——由同一类型的数据结构（或记录）构成的集合<br>查找——查询（Searching）特定元素是否在表中<br>查找成功——若表中存在特定元素，称查找成功，应输出该记录<br>查找不成功——否则，称查找不成功（也应输出失败标志或失败位置）<br>静态查找——只查找，不改变集合内的数据元素<br>动态查找——既查找，又改变（增减）集合内的数据元素<br>关键字——记录中某个数据项的值，可用来识别一个记录<br>主关键字——可以唯一识别一个记录的关键字<br>次关键字——识别若干记录的关键字</p><p><strong>顺序查找</strong>：以顺序表表示静态查找表，则Search函数可用顺序查找来表示。<br>技巧：把待查关键字key存入表头或表尾（俗称“哨兵”），这样可以加快执行速度。</p><p><strong>折半查找</strong>：每次将待查记录所在区间缩小一半<br>算法实现：设表长为n,low,high和mid分别指向待查元素所在区间的上界。下届和中点，k为给定值</p><p><strong>索引顺序查找</strong>又称分块查找<br>查找过程：将表分成几块，块内无序，块间有序；先确定待查记录所在块，再在块内查找</p><p>2、动态查找表（<strong>二叉排序树</strong>的定义、性质；二叉排序树的查找、插入和删除操作）（平衡二叉树不要求）<br><strong>二叉排序树定义</strong>：<br>(1)若它的左子树不为空，则左子树上所有节点的值均小于它的根节点的值；<br>(2)若它的右子树不为空，则右子树上所有节点的值均大于它的根节点的值；<br>(3)它的左、右子树也分别为二叉排序树。<br>（若为整型则直接比较大小，若为char型则比较首字母大小（以此类推））<br>性质：<strong>对二叉查找树进行中序遍历，即可得到有序的数列</strong><br>如何<strong>判断一棵树是否为二叉排序树</strong>？<br>左右子树以及当前元素在中序遍历中是否有序<br>或着判断根节点的左子树最大值是否小于根节点，右子树的最小值是否大于根结点</p><p><strong>查找</strong>：二叉查找树是对要查找的数据进行生成树，左支的值小于右支的值。在查找的时候也是一样的思路，从根节点开始，比节点大进入右支，比节点小进入左支，直到查找到目标值。</p><p><strong>插入</strong>：空树，就首先生成根节点；不是空树就按照查找的算法，找到父节点，然后作为叶子节点插入，如果值已经存在就插入失败。</p><p><strong>删除</strong>：<br>（1）如果删除的是叶节点，可以<strong>直接删除</strong>；<br>（2）如果被删除的元素有一个子节点，可以将<strong>子节点直接移到被删除元素的位置</strong>；<br>（3）如果有两个子节点，这时候就采用中序遍历，<strong>找到待删除的节点的后继节点</strong>，将其与待删除的节点互换，此时待删除节点的位置已经是叶子节点，可以直接删除。</p><p>3、了解<strong>哈希表</strong>的定义、哈希函数的<strong>构造思想和解决冲突的办法</strong>；重点掌握哈希表的构造方法；掌握哈希表的查找及性能分析（装填因子的概念及定性结论）。<br>掌握<strong>开放地址线性探测法、开放地址二次探测法和拉链法（链地址法）</strong></p><h2 id="第十章-内部排序"><a href="#第十章-内部排序" class="headerlink" title="第十章 内部排序"></a>第十章 内部排序</h2><p>理解各种排序算法的思想、稳定性和时空性能； </p><p><strong>直接插入，冒泡，归并排序都是稳定排序，希尔，快速，堆排序都是不稳定排序</strong></p><p>1、插入排序：直接插入排序、折半插入排序、希尔排序；<br><strong>直接插入排序(Straight Insertion Sort)</strong>：一种最简单的排序方法，它的基本操作是将一个记录插入到已排好的有序表中，从而得到一个新的、记录数增1的有序表。</p><p><strong>折半插入排序(Binary Insertion Sort)</strong>：由于插入排序的基本操作是在一个有序表中进行查找和插入，这个“查找”操作可利用“折半查找”来实现，由此进行的插入排序称之为折半插入排序</p><p><strong>希尔排序(Shell’s Sort)</strong>又称“缩小增量排序”(Diminishing Increment Sort)：先将整个待排序记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序</p><p>2、交换排序：冒泡、快速排序；<br><strong>起泡排序(Bubble Sort)</strong>：首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序，则将两个记录交换之，然后比较第二个记录和第三个记录的关键字。依此类推，直至第n-1个记录和第n个记录的关键字进行过比较为止。然后进行第二趟起泡排序，对前n-1个记录进行同样操作。</p><p><strong>快速排序(Quick Sort)</strong>：对起泡排序的一种改进，通过一趟排序将<strong>待排记录分割成独立的两部分</strong>，其中<strong>一部分记录的关键字均比另一部分记录的关键字小</strong>，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p>3、选择排序：直接选择排序、堆排序（堆概念，筛选、建堆、堆排序）；<br><strong>简单选择排序(Simple Selection Sort)</strong>：（直接选择排序）通过n-i次关键词间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1&lt;=i&lt;=n)个记录交换之</p><p><strong>堆排序(Heap Sort)</strong>：注意大根堆与小根堆如何建立。</p><p>4、归并排序： 2-路归并排序<br>“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。<br><strong>2-路归并排序</strong>：假设初始序列含有n个记录，则可看成n个有序的子序列，每个子序列的长度为1，然后两两归并，得到$\frac{n}{2}$个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为n的有序序列为止</p><p>数据库部分</p><h2 id="第一章-绪论-1"><a href="#第一章-绪论-1" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><p>一、了解<strong>数据、数据库、数据库系统、数据库管理系统</strong>的概念；了解数据库系统管理数据的特点；<br><strong>1、数据</strong><br>数据是数据库中的基本对象。我们传统的理解为数据就是数字，但是从狭义的方面去看的话，数据的种类确是很多的，就如文本、图像、图形、音频、视频、货物的运输情况等都是数据。<br>数据的定义为：描述事物的符号记录称为数据。<br>数据的语义是对数据含义的说明，数据的语义称为数据的含义，数据与其语义是不可分的。就像90是一个数据，可以是某个人的体重、也可以是某个同学的体重，更可以是计科班的小时人数。<br><strong>2、数据库</strong><br>严格的来说，<strong>数据库是长期储存在计算机内的、有组织的、可共享的大量数据的集合。</strong>数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。<br>概括的讲，数据库数据具有永久存储、有组织和可共享三个基本特点。<br><strong>3、数据库管理系统</strong>(DBMS)<br>数据库管理系统是解决如何科学地组织和存储数据，如何高效地获取和维护数据。<br>数据库管理系统是位于用户和操作系统之间的一层数据管理软件。数据库管理系统和操作系统一样是计算机的基础软件。<br><strong>4、数据库系统</strong><br>数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。<br>在不引起混淆的情况下，人们通常将数据库系统简称为数据库。</p><p>二、了解数据模型的要素：<strong>数据结构、数据操作、数据的完整性约束</strong>；了解概念模型的有关术语：<strong>实体、属性、码、域、实体型、实体集、联系</strong>，<strong>E-R图</strong>表示；了解数据模型的概念和种类；</p><p><strong>数据模型三要素</strong><br>1、<strong>数据结构</strong><br>是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合,即带“结构”的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。<br>2、<strong>数据操作</strong><br>数据模型中数据操作主要描述在相应的数据结构上的操作类型和操作方式。它是操作算符的集合，包括若干操作和推理规则，用以对目标类型的有效实例所组成的数据库进行操作。<br>主要指检索（select）和更新（update）：插入（insert）、删除（delete）、修改（update）两类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。数据操作是对系统动态特性的描述。<br>3、<strong>完整性约束</strong><br>主码不能为空<br>数据模型中的数据约束主要描述数据结构内数据间的语法、词义联系、他们之间的制约和依存关系，以及数据动态变化的规则，以保证数据的正确、有效和相容。它是完整性规则的集合，用以限定符合数据模型的数据库状态，以及状态的变化<br><strong>实体</strong>：就数据库而言，实体往往指某类事物的集合。也就是数据库表<br><strong>属性</strong>：实体之间相互区分的最基本特征，是对象或事物具象的描述。<br><strong>码</strong>是数据系统中的基本概念。所谓码就是能唯一标识实体的属性，他是整个实体集的性质，而不是单个实体的性质。它包括<strong>超码，候选码，主码</strong>。<br><strong>超码</strong>是一个或多个属性的集合，这些属性可以让我们在一个实体集中唯一地标识一个实体。<br><strong>候选码</strong>:关系(表)中的某个属性组,它可以唯一确定一个元组。<br>若一个关系(表)中有多个候选码,则选定其中一个为<strong>主码</strong><br><strong>全码</strong>:关系的所有属性都包含在候选码中。<br><strong>主属性</strong>:包含在任何一个候选码中的属性<br><strong>非主属性</strong> 不包含在任何码中的属性<br><strong>主码</strong>: 主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。<br><strong>外码</strong>： 外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。<br><strong>域</strong>(Domain):属性的取值范围<br><strong>实体型</strong>：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型<br><strong>实体集</strong>：所谓实体集就是同一类型实体的集合（一般是有限的）<br><strong>ER图</strong>画法：<br><img src="/.com//Blog\source\_posts\DataStructure-and-Database\9.png" alt="9"></p><p>三、理解数据库系统的模式结构，了解模式、数据独立性的概念；</p><p>四、了解数据库管理系统的功能（6方面功能）和组成（4部分）。<br><strong>数据库管理系统的功能</strong>包括以下几个方面：<br>1.数据定义功能<br>数据库管理系统提供数据定义语言，用户通过他可以方便的对数据库中的数据对象的组成和结构进行定义。<br>2.数据组织、存储和管理<br>数据库管理系统要分类组织、存储和管理各种数据，包括数据字典、用户数据、数据的存取路径等。要确定以何种文件结构和存取方式在存储级上组织这些数据，如何实现数据之间的联系。数据组织和存储的基本目标是提高存储空间利用率和方便存取，提供多种存取方法（如索引查找、hash查找、顺序查找等）来提高存取效率。<br>3.数据操纵功能<br>数据库管理系统还提供数据操纵语言（DML),用户可以使用它操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。<br>4.数据库的事务管理和运行管理<br>数据库在建立、运用和维护时由数据库管理系统统一管理和控制，以保证事务的正确运行，保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。<br>5.数据库的建立和维护功能<br>数据库的建立和维护功能包括数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。这些功能通常是由一些实用程序或管理工具完成的。<br>6.其他功能<br>其他功能包括数据库管理系统与网络中其他软件系统的通信功能，一个数据库管理系统与另一个数据库管理系统或文件系统的数据转换功能，异构数据库之间的互访和互操作功能等。</p><h2 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h2><p>1、了解关系模型的三个组成部分；<br>关系数据模型的<strong>数据结构</strong><br>主要描述数据的类型、内容、性质以及数据间的联系等，是目标类型的集合。<br>目标类型是数据库的祖成成分，一般可分为两类：数据类型、数据类型之间的联系。<br>关系数据模型的<strong>操作集合</strong><br>数据模型中数据操作主要描述在相应的数据结构上的操作类型和操作方式。它是操作算符的集合，包括若干操作和推理准则，用以对目标类型的有效实例所组成的数据库进行操作。<br>关系数据模型的<strong>完整性约束</strong><br>数据模型中的数据约束主要描述数据结构内数据间的语法、词义联系、他们之间的制约和依存关系，以及数据动态变化的规则，以保证数据的正确、有效和相容。它是完整性规则的集合，用以限定符合数据模型的数据库状态，以及状态的变化。<br>约束条件可以按不同的原则划分为数据值的约束和数据间联系的约束；静态约束和动态约束；实体约束和实体间的参照约束等</p><p>2、了解关系数据结构的形式化定义：域、笛卡儿积、关系及关系性质、关系模式，码；</p><p>3、理解关系的完整性，实体完整性和参照完整性；</p><p>4、掌握关系代数运算：<strong>并、交、差、广义笛卡儿积、选择、投影、连接、除</strong>；要求应用关系代数运算解决查询问题。<br>详情见</p><h2 id="第三章-关系数据库标准语言-SQL"><a href="#第三章-关系数据库标准语言-SQL" class="headerlink" title="第三章 关系数据库标准语言 SQL"></a>第三章 关系数据库标准语言 SQL</h2><p>1、掌握 SQL 的数据定义，<strong>创建、删除和修改基本表</strong>；了解基本数据类型；</p><p>2、掌握 SQL 的<strong>查询语句</strong>，单表查询（列、元组、排序、集函数（ AVG， SUM， COUNT， MAX， MIN），分组），连接查询（等值和非等值连接，自身连接，外连接，复合条件连接）， 嵌套查询（ IN，比较、 ANY， ALL， EXIST）；</p><p>3、掌握 SQL 的<strong>更新语句</strong>， INSERT， UPDATE， DELETE</p><p>4、了解 SQL 的<strong>视图</strong>（什么是视图）</p><h2 id="第四章-关系数据库设计理论"><a href="#第四章-关系数据库设计理论" class="headerlink" title="第四章 关系数据库设计理论"></a>第四章 关系数据库设计理论</h2><p>1、数据依赖：理解函数依赖，码；</p><p>2、掌握范式（ 1NF， 2NF， 3NF， BCNF），灵活应用；</p><p>3、关系模式的规范化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022春-数据结构与数据库&quot;&gt;&lt;a href=&quot;#2022春-数据结构与数据库&quot; class=&quot;headerlink&quot; title=&quot;2022春 数据结构与数据库&quot;&gt;&lt;/a&gt;2022春 数据结构与数据库&lt;/h1&gt;&lt;p&gt;数据结构部分&lt;/p&gt;
&lt;h2 id=&quot;第一章</summary>
      
    
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>A Small Talking</title>
    <link href="http://example.com/2022/06/07/A-Small-Talking/"/>
    <id>http://example.com/2022/06/07/A-Small-Talking/</id>
    <published>2022-06-06T19:39:18.000Z</published>
    <updated>2022-06-06T19:57:10.501Z</updated>
    
    <content type="html"><![CDATA[<p>已经是2022年6月7号的凌晨了，回想去年的今天我正意气风发的前往高考考场。。。我算是进入了梦寐以求的学府学习，这一年来很多坎坷，但我终归还算是成长不少。</p><p>数不清多少个日夜的绝望，冷淡一直萦绕着我，我不停地逃避。先是觉得专业不好，不该去学数学，常常找人发泄，倒垃圾，却落得个不受人待见的下场。后面又是觉得自己应当是快长大了，必须做出一点进步来改善现状。却一直将自己置于一个绝望的轮回。</p><p>刚上大学的新鲜感可以用来麻痹自己，逃避一些不想去面对的事务，我参加各种社工活动，我觉得自己能学很多课，我认为自己拥有创造力，可以写点儿什么玩意儿（事实证明我自己都不会去看）。结果就是，绩点荒废了，博客不管理了，朋友一个也不想见了，我逐步走向麻痹，不想去面对一切了。有时候感叹自己总是那么幼稚，会在外人面前说出很单纯，可笑的话，埋怨自己总是长不大。现在回想起来就是，只是我不愿意去长大罢了。我觉得人成为不了万花筒，就应该成为孤勇者。这是必然的，绝大部分人做不好所有事，要的只是你能对某一个领域有那么一点点的理解就行了。可我还是像个小孩子，觉得什么都该懂一点比较好。我懒惰、没有自控力与行动力，却还用所谓意志力麻痹自己，我是彻头彻尾的一个又蠢又坏的人。</p><p>好在我希望今晚是最后一晚了，接下来继续跟进自己的学习脚步，一开始整理的所谓学习笔记80%都不是自己原创，整理来自知乎，CSDN以及Google，我认为这没有什么，随着实力的逐步提升，我坚信后面的博客质量会对得起付出的努力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;已经是2022年6月7号的凌晨了，回想去年的今天我正意气风发的前往高考考场。。。我算是进入了梦寐以求的学府学习，这一年来很多坎坷，但我终归还算是成长不少。&lt;/p&gt;
&lt;p&gt;数不清多少个日夜的绝望，冷淡一直萦绕着我，我不停地逃避。先是觉得专业不好，不该去学数学，常常找人发泄，倒</summary>
      
    
    
    
    
    <category term="更新" scheme="http://example.com/tags/%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用数学记号</title>
    <link href="http://example.com/2021/11/23/Markdown%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E8%AE%B0%E5%8F%B7/"/>
    <id>http://example.com/2021/11/23/Markdown%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E8%AE%B0%E5%8F%B7/</id>
    <published>2021-11-23T13:03:51.000Z</published>
    <updated>2021-11-23T13:04:42.558Z</updated>
    
    
    
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>翁恺MOOC程序设计笔记</title>
    <link href="http://example.com/2021/11/16/%E7%BF%81%E6%81%BAMOOC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/11/16/%E7%BF%81%E6%81%BAMOOC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-16T08:56:45.000Z</published>
    <updated>2021-11-29T09:07:29.431Z</updated>
    
    <content type="html"><![CDATA[<p>前言：花了大概一周多的时间把C语言最基本的东西干完了，但这些东西大抵只是些皮毛。学习一个新东西，可以先观看视频了解大概轮廓，然后接下来啃书。</p><h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>输入是以行为单位进行的，行的结束标志就是按下了回车键。在按下回车之前，程序不会读到任何东西。</p><p>变量：保存数据的地方。用一个变量保存了数据，它才能参加到后面的计算中去。<br><strong>变量定义的一般形式：&lt;类型名称&gt;&lt;变量名称&gt;;</strong><br>变量的名字是一种“<strong>标识符</strong>”，用来识别这个和那个的不同的名字。<br><strong>标识符基本构造原则</strong>：只能由字母，数字和下划线组成，数字不可以出现在第一个位置上，C语言的关键字（有的地方称为<strong>保留字</strong>）不可以用做标识符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span>,<span class="hljs-keyword">break</span>,<span class="hljs-keyword">case</span>,<span class="hljs-keyword">char</span>,<span class="hljs-keyword">const</span>,<span class="hljs-keyword">continue</span>,<span class="hljs-keyword">default</span>,<br><span class="hljs-keyword">do</span>,<span class="hljs-keyword">double</span>,<span class="hljs-keyword">else</span>,<span class="hljs-keyword">enum</span>,<span class="hljs-keyword">extern</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">for</span>,<span class="hljs-keyword">goto</span>,<br><span class="hljs-keyword">if</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">long</span>,<span class="hljs-keyword">register</span>,<span class="hljs-keyword">return</span>,<span class="hljs-keyword">short</span>,<br><span class="hljs-keyword">signed</span>,<span class="hljs-keyword">sizeof</span>,<span class="hljs-keyword">static</span>,struct,<span class="hljs-keyword">switch</span>,<br><span class="hljs-keyword">typedef</span>,<span class="hljs-keyword">union</span>,<span class="hljs-keyword">unsigned</span>,<span class="hljs-keyword">void</span>,<span class="hljs-keyword">volatile</span>,<span class="hljs-keyword">while</span>,<br><span class="hljs-keyword">inline</span>,<span class="hljs-keyword">restrict</span><br></code></pre></td></tr></table></figure><p>(以上不需要背诵)<br>C语言没有强制要求变量在被定义时就初始化，但在第一次被使用之前应该被赋值一次。（如果没有初始化，则会随机出现奇怪的数值）<br><strong>变量初始化：&lt;类型名称&gt;&lt;变量名称&gt;=&lt;初始值&gt;;</strong><br><strong>表达式：有运算符的式子就叫做表达式。</strong><br>C99允许在程序的任何地方定义变量<br>传统ANSI C只能在代码开头的地方定义变量<br>固定不变的数，是常数。直接写在程序里，我们称作<strong>直接量（literal)</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义一个常量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> AMOUNT = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>const是一个修饰符，用来给这个变量加上一个const(不变的)的属性。<br>const属性表示这个变量的值一旦初始化，就不能再修改了。<br>若强行进行赋值操作，编译器会发现这个错误并且指出。</p><p>当浮点数和整数放在一起运算时，C会将整数转换成浮点数，然后进行浮点数的运算。<br>double双精度浮点数；float单精度浮点数</p><p>运算符(operator)是指进行运算的动作：加法运算符“+”，减法运算符“-”<br>算子(operand)指参与运算的值：常数，变量，某个方法的返回值</p><p><strong>运算符优先级</strong></p><div class="table-container"><table><thead><tr><th>优先级</th><th>运算符</th><th>运算</th><th>结合关系</th><th>举例</th></tr></thead><tbody><tr><td>1</td><td>+</td><td>单目不变</td><td>自右向左</td><td>a*+b</td></tr><tr><td>1</td><td>-</td><td>单目取负</td><td>自右向左</td><td>a*-b</td></tr><tr><td>2</td><td>*</td><td>乘</td><td>自左向右</td><td>a*b</td></tr><tr><td>2</td><td>/</td><td>除</td><td>自左向右</td><td>a/b</td></tr><tr><td>2</td><td>%</td><td>取余</td><td>自左向右</td><td>a%b</td></tr><tr><td>3</td><td>+</td><td>加</td><td>自左向右</td><td>a+b</td></tr><tr><td>3</td><td>-</td><td>减</td><td>自左向右</td><td>a-b</td></tr><tr><td>4</td><td>=</td><td>赋值</td><td>自右向左</td><td>a=b</td></tr></tbody></table></div><p>赋值运算符<br><strong>赋值也是运算，也有结果！</strong>a=6的结果是a被赋予的值，也就是6<br>不要用“嵌入式赋值”！！（不利于阅读，容易产生错误）</p><p>结合关系：一般自左向右（单目+-和赋值时自右向左）</p><p>设置断点：程序运行到断点时将会停止，不会执行被设为断点的那一行程序。（用来进行程序debug。）</p><p><strong>复合赋值</strong>：5个算术运算符，+-/%，可以和赋值运算符“=”结合起来，形成复合赋值运算符：“+=”，“-=”，“*=”，“/=”和“%=”（两个运算符中间不要有空格！）<br>例：total += 5;<br>        total = total + 5;</p><p><strong>递增递减运算符（++和—）</strong>：单目运算符，其算子必须是变量，作用是给这个变量+1或者-1。<br>前缀后缀：放在变量的前面叫做前缀形式，放在变量后面叫做后缀形式。<br><strong>a++的值是a加1以前的值，而++a的值是加了1以后的值。</strong></p><div class="table-container"><table><thead><tr><th>表达式</th><th>运算</th><th>表达式的值</th></tr></thead><tbody><tr><td>count++</td><td>给count加1</td><td>count原来的值</td></tr><tr><td>++count</td><td>给count加1</td><td>count+1以后的值</td></tr><tr><td>count—</td><td>给count减1</td><td>count原来的值</td></tr><tr><td>—count</td><td>给count减1</td><td>count-1以后的值</td></tr></tbody></table></div><p><strong>关系运算：计算两个值之间的关系</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:center">相等</td></tr><tr><td style="text-align:center">！=</td><td style="text-align:center">不相等</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于或等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于或等于</td></tr></tbody></table></div><p><strong>关系运算的结果：当两个值的关系符合关系运算符的预期时，关系运算的结果为整数1，否则为整数0。</strong><br>关系运算符的<strong>优先级</strong>：所有的关系运算符的优先级<strong>比算数运算符的低</strong>，但是<strong>比赋值运算的高</strong>。==与！=的优先级比其他的低，而连续的关系运算是<strong>从左到右</strong>进行的。</p><p>if语句：如果表示条件的逻辑表达式的结果<strong>不是0</strong>，那么就执行后面跟着的大括号中的语句，否则就跳过这些语句不执行，而继续下面的其他语句。</p><p><strong>else总是和最近的那个if去匹配（不添加大括号的情况下）。</strong><br>良好的习惯：<strong>在if或else后面总是用{}</strong>（即使只有一条语句的时候）。</p><p>if-else常见的错误：忘了大括号；if后面加分号（C编译器不会认为凭空出现的大括号有问题！）；错误使用==和=（程序会出现warning!）；</p><p>switch-case语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span>(控制表达式) <span class="hljs-comment">//控制表达式只能是整数型的结果</span><br>&#123;                <span class="hljs-comment">//常量可以是常数，也可以是常数计算的表达式</span><br>   <span class="hljs-keyword">case</span> 常量:    <br>        语句   <br>        ....<br>   <span class="hljs-keyword">case</span> 常量:<br>        语句<br>        ....<br>   <span class="hljs-keyword">default</span>:<br>        语句<br>        ....<br>&#125;<br><span class="hljs-comment">//在执行完分支中的最后一条语句后，如果后面没有break,就会顺序执行到下面的case里去，直到遇到一个break或者switch结束为止。</span><br><span class="hljs-comment">//case只是一个入口，而没有将switch划分！</span><br></code></pre></td></tr></table></figure><p>编写代码尽量满足<strong>“单一出口”</strong>原则：一个函数里面只有末尾一个return（或者void函数完全没有return而在最后一个语句之后自动返回），中间没有其他的return语句。</p><p>while循环体内需要有改变条件的机会，否则将会成为死循环。<br>while翻译作“当”：当条件满足时，不断地重复循环体内的语句。（条件成立时循环继续的条件）</p><p>do-while循环（执行完一轮循环体的代码后，再来检查循环体的条件是否满足，如果满足则继续下一轮循环，不满足则结束循环）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span><br>&#123;<br>    &lt;循环体语句&gt;<br>&#125;<span class="hljs-keyword">while</span>(&lt;循环条件&gt;);<br></code></pre></td></tr></table></figure><p>计数循环小套路：如果要模拟运行一个很大次数的循环，可以模拟较少的循环次数，然后作出推断。</p><p><strong>随机数：每次召唤rand（）就得到一个随机的整数。</strong></p><p>for(初始条件；循环继续的条件；循环每一轮要做的事情)<br>for=对于<br>for(count=10;count&gt;0;count—)<br>读作：“对于一开始的count=10,当count&gt;0时，重复做循环体，每一轮循环在做完循环体内语句后，使得count—。”<br>小套路：做求和的程序时，记录结果的变量应该初始化为0，而做求积的变量时，记录结果的变量应该初始化为1。<br>循环控制变量i只在循环里被使用了，在循环外面它没有任何用处。因此，我们可以把<strong>变量i的定义写到for语句里面去</strong>。（在C99里面用！）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br></code></pre></td></tr></table></figure><p>for中的每一个表达式都是可以<br><strong>for(;条件;)==while(条件)</strong></p><p><strong>Tips for loops:如果有固定次数，用for；如果必须执行一次，用do-while；其他情况用while</strong></p><p><strong>break：跳出循环</strong><br><strong>continue：跳过循环这一轮剩下的语句进入下一轮</strong><br>break和continue只能对它所在的那层循环做<br><strong>goto语句：无条件转移（不建议使用，只使用在多重循环结构中）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">goto</span> out;<br>&lt;语句&gt;<br>out:<br></code></pre></td></tr></table></figure><h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>C++/Java更强调类型，对类型的检查更严格<br>JavaScript,Python,PHP不看重类型，甚至不需要事先定义。</p><p>C语言的类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">·整数<br> ·<span class="hljs-keyword">char</span>,<span class="hljs-keyword">short</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">long</span>,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span><br>·浮点数<br> ·<span class="hljs-keyword">float</span>,<span class="hljs-keyword">double</span>,<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span><br>·逻辑<br> ·<span class="hljs-keyword">bool</span><br>·指针<br>·自定义类型<br></code></pre></td></tr></table></figure><p><strong>表达的数的范围:char&lt;short&lt;int&lt;float&lt;double</strong></p><p>sizeof：是一个运算符，给出某个类型或变量在内存中所占据的字节数<br>sizeof(int);sizeof(i);<br>sizeof（）函数的意思是输出括号内的变量所占的内存空间。<strong>（只看表达式的数据类型！）</strong></p><p>整数</p><div class="table-container"><table><thead><tr><th style="text-align:center">整数</th><th style="text-align:center">大小</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1字节（8比特）</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2字节</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">取决于CPU，通常的意义是“1个字”</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">取决于CPU，通常的意义是“1个字”</td></tr><tr><td style="text-align:center">long long</td><td style="text-align:center">8字节</td></tr></tbody></table></div><p>整数的内部表达：计算机内部一切都是二进制 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">18</span>--&gt;<span class="hljs-number">00010010</span><br><span class="hljs-number">0</span>--&gt;<span class="hljs-number">00000000</span><br><span class="hljs-number">-18</span>--&gt;?<br></code></pre></td></tr></table></figure><p>二进制负数<br>1个字节可以表达的数：00000000—11111111（0-255）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>仿制十进制，有一个特殊的标志表示负数<br><span class="hljs-number">2.</span>取中间的数为<span class="hljs-number">0</span>，如<span class="hljs-number">100000000</span>表示<span class="hljs-number">0</span>，比它小的是负数，比它大的是正数<br><span class="hljs-number">3.</span>补码<br></code></pre></td></tr></table></figure><p><strong>补码的意义就是拿补码和原码可以加出一个溢出的“零”</strong></p><p>数的范围：对于一个字节（8位），可以表达的是<br>00000000-11111111<br>00000000-&gt;0,11111111~10000000-&gt;-1~-128,00000001~01111111-&gt;1~127<br>11111111被当作纯二进制看待时，是255，被当作补码看待时是-1<br>如果一个字面量常数想要表达自己是unsigned，可以在后面加u或U<br>用l或L表示long(long)<br>*unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位</p><p>整数的输入输出<br>只有两种形式：int或long long<br>%d：int<br>%u：unsigned<br>%ld：long long<br>%lu：unsigned long long</p><p>8进制和16进制<br>一个以0开始的数字<strong>字面量</strong>是8进制<br>一个以0x开始的数字<strong>字面量</strong>是16进制<br>%o用于8进制，%x用于16进制<br>8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关！</p><p>选择整数类型<br>整数这么多种的原因：为了准确表达内存，做底层程序的需要<br><strong>没有特殊需要，就选择int</strong><br>现在的CPU字长都是32位或者64位，一次内存读写就是一个int，一次计算也是一个int（选择更短的类型不会更快，甚至可能更慢）<br><em>现代编译器一般会设计<em>*内存对齐</em></em>，所以更短的类型实际在内存中有可能也占据一个int的大小<br>unsigned与否只是输出的不同，内部计算是一样的！ </p><p><strong>浮点类型</strong></p><div class="table-container"><table><thead><tr><th>类型</th><th>scanf</th><th>printf</th><th>字长</th><th>范围</th><th>有效数字</th></tr></thead><tbody><tr><td>float</td><td>%f</td><td>%f,%e</td><td>32</td><td>(-2^128 ~ +2^128),0,±inf,nan</td><td>7</td></tr><tr><td>double</td><td>%lf</td><td>%f,%e</td><td>64</td><td>(-2^1024 ~ +2^1024),0,±inf,nan</td><td>15</td></tr></tbody></table></div><p>%e:输出科学计数法<br>可选的+或-符号，可以用e或E，小数点也可选，符号可以是-或+也可以省略（表示+）<br>-5.67E+16</p><p>输出精度：在%和f之间加上.n可以指定输出小数点后几位，这样的输出是做四舍五入的。<br>超过范围的浮点数<br>printf输出inf表示超过范围的浮点数：±∞<br>printf输出nan表示不存在的浮点数</p><p><strong>带小数点的字面量是double而非float</strong><br>float需要用f或F后缀来表明身份<br>注意：f1==f2可能失败！可以用fabs(f1-f2)&lt;1e-12来判断</p><p>浮点数的内部表达：<br>浮点数在计算时是由专用的硬件部件实现的<br>计算double和float所用的部件是一样的<br>选择浮点类型：<strong>如果没有特殊需求，只使用double!</strong><br>*现代CPU能直接对double做硬件计算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢</p><p>字符类型（character）<br>char是一种整数，也是一种特殊的类型：字符<br>用单引号表示的字符字面量：’a’,’1’<br>‘ ‘也是一个字符<br>printf和scanf里用%c来输入输出字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">char</span> d;<br>    c = <span class="hljs-number">1</span>;<br>    d = <span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c=%d\n&quot;</span>,c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d=%d\n&quot;</span>,d);<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>简单讲”%d %c”可以以0个或多个空白字符（空格、tab键、回车等）作为分隔符，同时%c不会读取空白字符，%c读取的一定是一个非空白字符，而 “%d%c”会读取一个数和紧挨着这个数的一个字符（包括空白字符）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %c&quot;</span>,&amp;i,&amp;c);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>,&amp;i,&amp;c);<br></code></pre></td></tr></table></figure><p>大小写转换<br>大写字母和小写字母是分开排列的，并不在一起（小写字母靠后一些）<br>‘a’-’A‘可以得到两端之间的距离，于是<br><strong>a+’a’-‘A’可以把一个大写字母变成小写字母；a+’A’-‘a’可以把一个小写字母变成大写字母</strong><br><img src="/.com//Blog\source\_posts\翁恺MOOC程序设计笔记\ascii.jpg" alt="ascii"></p><p><strong>逃逸字符</strong>：用来表示无法打印出来的控制字符或特殊字符，它由一个反斜杠“\”开头，后面跟上另一个字符，这两个字符合起来，组成了一个字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请分别输入身高的英尺和英寸，&quot;</span><br>      <span class="hljs-string">&quot;如输入\&quot;5 7\&quot;表示5英尺7英寸：&quot;</span>);<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>字符</th><th>意义</th><th>字符</th><th>意义</th></tr></thead><tbody><tr><td>\b</td><td>回退一格</td><td>\“</td><td>双引号</td></tr><tr><td>\t</td><td>到下一个表格位</td><td>\‘</td><td>单引号</td></tr><tr><td>\n</td><td>换行</td><td>\\</td><td>反斜杠本身</td></tr><tr><td>\r</td><td>回车</td><td></td></tr></tbody></table></div><p>自动类型转换：当运算符的两边出现不一致的类型时，会自动转换成较大的类型（大的意思是能表达的数的范围更大）<br>char—&gt;short—&gt;int—&gt;long—&gt;long long<br>int—&gt;float—&gt;double<br>对于printf，任何小于int的类型会被转换成int；float会被转换成double<br>但是scanf不会，要输入short，需要%hd</p><p>强制类型转换：要把一个量强制转换成另一个类型（通常是较小的类型），需要:（类型）值<br>比如：(int)10.2 (short)32<br>注意这时候的安全性，小的变量不总能表达大的量<br>只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型都不改变<br><strong>强制类型转换的优先级高于四则运算</strong></p><p>bool类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>之后就可以使用bool和true,false</p><p>逻辑运算：对逻辑量进行的运算，<strong>结果只有0或1</strong><br>逻辑量是关系运算或逻辑运算的结果</p><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>!</td><td>逻辑非</td><td>!a</td><td>如果a是true结果就是false,如果a是false结果就是true</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td><td>a&amp;&amp;b</td><td>如果a和b都是true,结果就是true；否则就是false</td></tr><tr><td>\</td><td>\</td><td></td><td>逻辑或</td><td>a\</td><td>\</td><td>b</td><td>如果a和b有一个是true,结果就是true；两个都是false,结果就是false</td></tr></tbody></table></div><p><strong>优先级：！&gt; &amp;&amp; &gt; ||</strong></p><div class="table-container"><table><thead><tr><th>优先级</th><th>运算符</th><th>结核性</th></tr></thead><tbody><tr><td>1</td><td>()</td><td>从左到右</td></tr><tr><td>2</td><td>! + - ++ —</td><td>从右到左（单目的+和-）</td></tr><tr><td>3</td><td>* / %</td><td>从左到右</td></tr><tr><td>4</td><td>+-</td><td>从左到右</td></tr><tr><td>5</td><td>&lt; &lt;= &gt; &gt;=</td><td>从左到右</td></tr><tr><td>6</td><td>== !=</td><td>从左到右</td></tr><tr><td>7</td><td>&amp;&amp;</td><td>从左到右</td></tr><tr><td>8</td><td>\</td><td>\</td><td></td><td>从左到右</td></tr><tr><td>9</td><td>= += -= *= /= %=</td><td>从右到左</td></tr></tbody></table></div><p><strong>短路：逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算</strong><br>a==6&amp;&amp;b==1<br>a==6&amp;&amp;b+=1<br>对于&amp;&amp;，左边是false时就不做右边了<br>对于||，左边是true时就不做右边了<br><strong>不要把赋值，包括复合赋值组合进表达式！</strong></p><p>条件运算符（三目运算符）<br>count = (count &gt; 20) ? count - 10 : count + 10;<br>条件、条件满足时的值和条件不满足时的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>（count &gt; <span class="hljs-number">20</span> )<br>    count = count - <span class="hljs-number">10</span>;<br><span class="hljs-keyword">else</span><br>    count = count + <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>条件运算符的优先级高于赋值运算符，但是低于其他运算符<br><strong>不要用嵌套条件表达式！</strong></p><p>逗号运算：逗号用来连接两个表达式，并以其<strong>右边的表达式的值作为它的结果</strong>。逗号的<strong>优先级是所有的运算符中最低的</strong>，所以它两边的表达式会先计算；逗号的组合关系是<strong>自左向右</strong>，所以<strong>左边的表达式会先计算</strong>，而<strong>右边的表达式的值就留下来作为逗号运算的结果</strong>。<br>主要是在for中使用逗号运算</p><p><strong>“代码复制”是程序质量不良的表现！</strong></p><h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>函数是一块代码，接受零个或多个参数，做一件事情，并返回零个或一个值。<br>函数定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span>  <span class="hljs-comment">//函数头：返回类型 函数名 参数表</span></span><br><span class="hljs-function">    <span class="hljs-comment">//函数体</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> sum =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>( i= begin ;i&lt;=end ; i++ )<br>    &#123;<br>        sum +=i;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d到%d的和是%d\n&quot;</span>, begin, end, sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用函数：函数名（参数值）;<br>()起到了表示函数调用的重要作用，即使没有参数也需要()<br>如果有参数，则需要给出正确的数量和顺序，这些值会被按照顺序依次用来初始化函数中的参数<br>如果函数有参数，调用函数时必须传递给它数量、类型正确的值<br>可以传递给函数的值是表达式的结果（字面量、变量、函数返回值、计算结果）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a,b,c;<br>a = <span class="hljs-number">5</span>;<br>b = <span class="hljs-number">6</span>;<br>c - max(<span class="hljs-number">10</span>,<span class="hljs-number">12</span>);<br>c = max(a, b);<br>c = max(c,<span class="hljs-number">23</span>);<br>c = max(max(<span class="hljs-number">23</span>,<span class="hljs-number">45</span>), a);<br>c = max(<span class="hljs-number">23</span>+<span class="hljs-number">45</span>, b);<br></code></pre></td></tr></table></figure><p>如果类型不匹配，调用函数时给的值与参数的类型不匹配是C语言传统上最大的漏洞（编译器总是<strong>悄悄替你把类型转换好</strong>，但是很可能不是你所预期的）后续的语言，C++/Java在这方面很严格</p><p>从函数中返回值<br><strong>return停止函数的执行，并送回一个值</strong><br>return;<br>return 表达式;<br>一个函数里面可以出现多个return语句<br>从函数中返回值：可以赋值给变量，可以再传递给函数，甚至可以丢弃</p><p>没有返回值的函数<br>void函数名（参数表）<br>不能使用带值的return，可以没有return<br>调用的时候不能做返回值的赋值</p><p><strong>函数先后关系</strong><br>C的编译器自上而下顺序分析代码<br>函数原型：函数头，以分号“;”结尾（目的是告诉编译器这个函数长什么样）<br>可以使用函数原型声明（区别于定义，定义包括函数体，可以放在main后面）</p><p>C语言在调用函数时，永远只能传值给函数<br><strong>传值：每个函数都有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系</strong><br>（过去）对于函数参数表中的参数，叫做“形式参数”，调用函数时给的值，叫做“实际参数”（很容易误会调用函数的时候把变量而不是值传进去了）</p><p><strong>本地变量</strong>：函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量（<strong>局部变量</strong>）（自动变量：生存期与作用域）<br>定义在函数内部的变量就是本地变量（参数也是本地变量）</p><p><strong>变量的生存期和作用域</strong><br>生存期：什么时候这个变量开始出现了，到什么时候它消亡了<br>作用域：在（代码的）什么范围内可以访问这个变量（这个变量可以起作用）<br>对于本地变量，这两个问题的答案是统一的：大括号内——块</p><p><strong>本地变量的规则</strong><br>本地变量是定义在块内的，可以定义在函数的块内，也可以定义在语句的块内<br>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了<br>快外面定义的变量在里面仍然有效<br>块里面定义了和外面同名的变量则覆盖了外面的<br>本地变量不会被默认初始化<br>参数在进入函数的时候被初始化了</p><p><strong>函数原型里面的参数类型一定要写明，如果没有就写void，不能留空！</strong></p><p>调用函数时的圆括号里的逗号<strong>是标点符号，不是运算符</strong></p><p>C语言不允许函数嵌套定义</p><p>定义数组<br>&lt;类型&gt;变量名称[元素数量];<br>元素数量必须是整数<br>数组是一种容器（放东西的东西）<br>其中所有的元素具有相同的数据类型<br>一旦创建，不能改变大小<br>*数组中的元素在内存中是连续依次排列的</p><p>使用数组时放在[]中的数字叫做下标或索引，下标从0开始计数<br>编译器和运行环境都不会检查数组下标是否越界，无论是对数组单元做读还是写<br>一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃(segmentation fault)<br>但是也可能运气好，没造成严重的后果（程序员来保证程序只使用有效的下标值：[0,数组的大小-1]）</p><p>数组的集成初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">23</span>,<span class="hljs-number">14</span>,<span class="hljs-number">32</span>&#125;<br><span class="hljs-comment">//直接用大括号给出数组的所有元素的初始值</span><br><span class="hljs-comment">//不需要给出数组的大小，编译器自动数数</span><br></code></pre></td></tr></table></figure><p>集成初始化时的定位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>] = &#123; [<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>, [<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-comment">//用[n]在初始化数据中给出定位</span><br><span class="hljs-comment">//没有定位的数据接在前面的位置后面</span><br><span class="hljs-comment">//其他位置的值补零</span><br><span class="hljs-comment">//也可以不给出数组的大小，让编译器算</span><br><span class="hljs-comment">//特别适合初始数据稀疏的数组</span><br></code></pre></td></tr></table></figure><p><strong>sizeof给出整个数组所占据的内容的大小，单位是字节**</strong><br><strong>sizeof(a)/sizeof(a[0])</strong><br>sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单位个数</p><p>数组变量本身不能被赋值<br>要把一个数组的所有元素交给另一个数组，必须采用<strong>遍历</strong><br>遍历数组：通常都是使用for循环，让循环遍历i从0到&lt;数组的长度，这样循环体内最大的i正好是数组最大的有效下标<br>常见错误：循环结束条件是&lt;=数组长度；离开循环后，继续用i的值来做数组元素的下标</p><p><strong>数组作为函数参数时，往往必须再用另一个参数来传入数组的大小</strong><br>数组作为函数的参数时：不能在[]中给出数组的大小，不能再利用sizeof来计算数组的元素个数</p><h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><p>二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">5</span>];<br><span class="hljs-comment">//通常理解为a是一个3行5列的矩阵</span><br></code></pre></td></tr></table></figure><p>二维数组的遍历（需要多重循环）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span> ;i++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">5</span>;j++)<br>    &#123;<br>        a[i][j] = i*j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二维数组的初始化</strong><br>列出是必须给出的，行数可以由编译器来数<br>每行一个{}，逗号分割<br>最后的逗号可以存在<br>如果省略，表示补零<br>也可以用定位</p><p><strong>运算符&amp;</strong><br>scanf(“%d”,&amp;i);里的&amp;<br>获得变量的地址，它的操纵数必须是变量<br>地址的大小是否与int相同取决于编译器</p><p>指针：就是保存地址的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">int</span>* p = &amp;i;<br><span class="hljs-keyword">int</span>* p,q;<br><span class="hljs-keyword">int</span> *p,q;<br><span class="hljs-comment">//三四行等价，表示p是指针，q是一个普通的变量</span><br></code></pre></td></tr></table></figure><p>指针变量：变量的值是内存的地址<br>普通变量的值是实际的值<br>指针变量的值是<strong>具有实际值的变量</strong>的地址</p><p>作为参数的指针<br>void f(int *p);<br>在被调用的时候得到了某个变量的地址：<br>int i=0;f(&amp;i);<br>在函数里面可以通过这个指针访问外面的这个i</p><p>访问那个地址上的变量<em></em>是一个单目运算符，用来访问指针的值所表示的地址上的变量<br>可以做右值也可以做左值<br><em>左值之所以叫左值是因为出现在赋值号左边的不是变量，而是值，是<em>*表达式计算的结果</em></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">a[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;<br>*p = <span class="hljs-number">3</span>;<br><span class="hljs-comment">//本质上两者(取0下标和取p的地址)都是运算的结果</span><br></code></pre></td></tr></table></figure><p>指针的运算符&amp;*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">*&amp;yptr -&gt; *(&amp;yptr) -&gt; * (yptr的地址) -&gt; 得到那个地址上的变量 -&gt; yptr<br>&amp;*yptr -&gt; &amp;(*yptr) -&gt; &amp;(y) -&gt; 得到y的地址，也就是yptr -&gt; yptr<br><span class="hljs-comment">//互相反作用</span><br></code></pre></td></tr></table></figure><p>传入地址<br>int i;scanf(“%d”,i);为什么编译没有报错？<br>i的值和它的地址刚好都是整数，scanf看不出区别</p><p>指针应用场景<br>一、交换两个变量的值<br>二、函数返回多个值，某些值就只能通过指针返回（传入的参数实际上是需要保存     带回的结果的变量）<br>三、函数返回运算的状态，结果通过指针返回<br>常见套路：<strong>让函数返回特殊的不属于有效范围内的值来表示出错</strong><br>（后续的语言（C++，Java）采用了异常机制来解决这个问题）</p><p><strong>指针最常见的错误</strong><br><strong>定义了指针变量，还没有指向任何变量，就开始使用指针</strong></p><p>传入函数的数组组成了什么？<br><strong>函数参数表中的数组实际上是指针</strong><br>sizeof(a)==sizeof(int*)<br>但是可以用数组的运算符[]进行运算</p><p>数组参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以下四种函数原型是等价的:</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ar,<span class="hljs-keyword">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *,<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar[],<span class="hljs-keyword">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [],<span class="hljs-keyword">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>数组变量是特殊的指针<br>数组变量本身表达地址，所以<br>int a[10];int <em>p=a;（无需用&amp;取地址）<br>但是数组的单元表达的是变量，需要用&amp;取地址<br>a == &amp;a[0]<br>[]运算符可以对数组做，也可以对指针做：<br>p[0] &lt;==&gt; a[0]   (p是指针，a是数组)</em>运算符可以对指针做，也可以对数组做：<br><em>a = 25;<br><strong>数组变量是const的指针，所以不能被赋值</strong><br>int b[] —&gt; int </em> const b;（数组变量是一个常量指针）</p><p><strong>指针是const：表示一旦得到了某个变量的地址，不能再指向其他变量</strong><br><strong>指针所指是const：表示不能通过这个指针去修改那个变量</strong></p><p><strong>const数组</strong><br>const int a[] = {1,2,3,4,5,6,}<br>数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int<br>所以必须通过初始化进行赋值</p><p>因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值<br>为了保护数组不被函数破坏，可以设置参数为const<br>int sum(const int a[],int length);</p><p>给一个指针加1表示要让指针指向下一个变量<br>如果指针不是指向一片连续分配的空间（如数组，则这种运算没有意义）<br><strong>指针计算</strong><br>这些算术运算可以对指针做：<br>给指针加、减一个整数（+，+=，-，-=）<br>递增递减（++/—）<br>两个指针相减：</p><p><strong>*p++</strong><br>取出p所指的那个数据来，完事之后顺便把p移到下一个位置去<br>*的优先级虽然高，但是没有++高<br>常用于数组类的连续空间操作<br>在某些CPU上，这可以直接被翻译成一条汇编指令</p><p><strong>指针比较</strong><br>&lt;,&lt;=,==,&gt;,&gt;=,!=都可以对指针做<br>比较它们在内存中的地址<br>数组中的单元的地址肯定是线性递增的</p><p>指针的类型<br>无论指向什么类型，所有的指针的大小都是一样的，因为都是地址<br>但是指向不同类型的指针是不能直接互相赋值的（为了避免用错指针）</p><p>用指针来做什么<br>需要传入较大的数据时用作参数<br>传入数组后对数组做操作<br>函数返回不止一个结果<br>需要用函数来修改不止一个变量<br>动态申请内存</p><h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><p>字符数组<br>char word[] = {‘H’,’e’,’l’,’l’,’o’,’!’};<br>这不是C语言的字符串，因为不能用字符串的方式做计</p><p>字符串<br>char word[] = {‘H’,’e’,’l’,’l’,’o’,’!’,’\0’};<br>以0（整数0）结尾的一串字符<br>0或’\0’是一样的，但是和’0’不同<br>0标志字符串的结束，但它不是字符串的一部分<br>计算字符串长度的时候不包含这个0<br>字符串以数组的形式存在，以数组或指针的形式访问（更多的是以指针的形式）<br>string.h里有很多处理字符串的函数</p><p>字符串变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">char</span> word[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">char</span> line[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;Hello&quot;</span>;<br></code></pre></td></tr></table></figure><p>字符串常量<br>“Hello”<br>“Hello”会被编译器变成一个字符数组放在某处，这个数组的长度是，结尾还有表示结束的0</p><p>C语言的字符串是以字符数组的形态存在的<br>不能用运算符对字符串做运算<br>通过数组的方式可以遍历字符串<br>唯一特殊的地方是<strong>字符串字面量可以用来初始化字符数组</strong></p><p>字符串常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *s = <span class="hljs-string">&quot;Hello,world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>s是一个指针，初始化为指向一个字符串常量<br>由于这个常量所在的地方，所以实际上s是const char *s，但是由于历史的原因，编译器接受不带const的写法<br>但是试图对s所指的字符串做写入会导致严重的后果<br>如果需要修改字符串，应该用数组：char s[] = “Hello, world!”;（此时是可以修改的）</p><h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><p>程序需要字符串时，应该用指针还是数组？<br>数组：这个字符串在这里（作为本地变量空间自动被回收）<br>指针：不知道在哪里（<strong>处理参数，动态分配空间</strong>）<br>如果要构造一个字符串—&gt;指针<br>如果要处理一个字符串—&gt;数组</p><p>char<em>不一定是字符串，本意是<em>*指向字符的指针</em></em>，只有它所指的字符数组有结尾的0，才能说它所指的字符串!</p><p>字符串输入输出<br><strong>scanf读入一个单词（到空格、tab或回车为止）</strong>此时的scanf是不安全的，因为不知道要读入的内容的长度!<br>在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一</p><p>常见错误：（野指针）<br>char *string;<br>scanf(“%s”,string);<br>如果string没有指向对程序有害的内存空间，可能不会报错；但一旦指向了有害的空间，强行写入将导致程序出错（崩溃）</p><p>空字符串<br>char buffer[100]=””;<br>这是一个空的字符串，buffer[0]==’\0’<br>char buffer[]=””;这个数组的长度只有1！</p><p>字符串数组<br>char <em>*a<br>a是一个指针，指向另一个指针，那个指针指向一个字符（串）<br>char </em>a[]是一个指针数组，指向字符串</p><p>putchar函数<br>int putchar(int c);<br>向标准输出写一个字符<br>返回写了几个字符，EOF(-1)表示写失败</p><p>getchar函数<br>int getchar(void)<br>从标准输入读入一个字符<br>返回类型是int是为了返回EOF(-1)</p><p>string.h文件包括了：strlen,strcmp,strcpy,strcat,stchr,strstr</p><p>strlen<br>size_t strlen(const chat *s)——这里的const表示不会通过s修改字符串<br>返回s的字符串长度（不包括结尾的0）</p><p>strcmp<br>int strcmp(const char <em>s1,const char </em>s2)<br>比较两个字符串，返回:<br>0:s1==s2<br>1:s1&gt;s2<br>-1:s1&lt;s2</p><p>strcpy<br>char <em>strcpy(char </em>restrict dst,const char <em>restrict src);<br>把src的字符串拷贝到dst<br><em>*restrict表明src和dst不重叠</em></em><br>返回dst<br>为了能链起代码来</p><p>strcat<br>char <em>strcat(char </em>restrict s1,const char *restrict s2);<br>把s2拷贝到s1的后面，接成一个长的字符串<br>返回s1<br>s1必须具有足够的空间</p><p>strcpy和strcat都可能出现安全问题，尽可能地不使用它<br>安全版本<br>char <em>strncpy(char </em>restrict dst,const char <em>restrict src,size_t n);<br>char </em>strncat(char <em>restrict s1,const char </em>restrict s2,size_t n);<br>int strncmp(const char <em>s1,const char </em>s2,size_t n);只看前n个</p><p>常量符号化：用符号而不是具体的数字来表示程序中的数字<br><strong>枚举：一种用户定义的数据类型</strong>，它用关键字enum以如下语法来声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举类型名字&#123;</span>名字<span class="hljs-number">0</span>,,,名字n&#125;<br></code></pre></td></tr></table></figure><p>枚举类型名字通常并不真的使用，要用的是在大括号里的名字，因为它们就是常量符号，它们的类型是int，值则依次从0到n</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">colors</span>&#123;</span>red,yellow,green&#125;;<br><span class="hljs-comment">//创建了三个常量，red的值是0，yellow是1，而green是2</span><br></code></pre></td></tr></table></figure><p>当需要一些可以排列起来的常量值时，定义枚举的意义就是给了这些常量值名字<br>枚举量可以作为值，枚举类型可以跟上enum作为类型，但是<strong>实际上是以整数来做内部计算和外部输入输出的</strong><br>套路：<strong>自动计数的枚举</strong>（需要遍历所有的枚举量或者需要建立一个用枚举量做下标的数组的时候就很方便了）<br>枚举量：声明枚举量的时候可以指定值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">COLOR</span>&#123;</span>RED=<span class="hljs-number">1</span>,YELLOW,GREEN=<span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//此处的YRLLOW=2</span><br></code></pre></td></tr></table></figure><p>枚举只是int，即使给枚举类型的变量赋不存在的整数值也没有任何的warning或error<br><strong>实际上很少用枚举</strong>（一般用于有意义上排比的名字，比用const int方便）<br>枚举比宏（macro）好，因为枚举有int类型</p><h1 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h1><p><strong>声明结构类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> &#123;</span><br>    <span class="hljs-keyword">int</span> month;<br>    <span class="hljs-keyword">int</span> day;<br>    <span class="hljs-keyword">int</span> year;<br>&#125;;<span class="hljs-comment">//最常见错误：漏了这个分号！</span><br></code></pre></td></tr></table></figure><p>和本地变量一样，在函数内部声明的结构类型只能在函数内部使用<br>所以<strong>通常在函数外部声明结构类型</strong>，这样就可以被多个函数所使用了</p><p><strong>声明结构的形式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> &#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p1</span>,<span class="hljs-title">p2</span>;</span><br>p1和p2都是point<br>里面有x和y的值<br>    <br><span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>&#125;p1,p2;<br>p1和p2都是一种无名结构，里面有x和y<br>    <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>&#125;p1,p2;<br>p1和p2都是point<br>里面有x和y的值t<br><span class="hljs-comment">//对于第一和第三种形式，都声明了结构point，但是第二种形式没有声明point，只是定义了两个变量</span><br></code></pre></td></tr></table></figure><p><strong>结构的初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> &#123;</span><br>    <span class="hljs-keyword">int</span> month;<br>    <span class="hljs-keyword">int</span> day;<br>    <span class="hljs-keyword">int</span> year;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">today</span> =</span> &#123;<span class="hljs-number">07</span>,<span class="hljs-number">31</span>,<span class="hljs-number">2014</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">thismonth</span> =</span> &#123;.month=<span class="hljs-number">7</span>,.year=<span class="hljs-number">2014</span>&#125;;<span class="hljs-comment">//没有给值的话默认为0</span><br></code></pre></td></tr></table></figure><p>结构成员<br>结构和数组有点像<br>数组用[]运算符和下标访问其成员(例如a[0] = 10;）<br><strong>结构用.运算符和名字访问其成员</strong><br>today.day<br>student.firstName<br>p1.x<br>p1.y</p><p>结构运算<br>要访问整个结构，直接用结构变量的名字<br>对于整个结构，可以做赋值，取地址，也可以传递给函数参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">p1 = (struct point)&#123;<span class="hljs-number">5</span>,<span class="hljs-number">10</span>&#125;;  <span class="hljs-comment">//相当于p1.x = 5;p1.y = 10;(对结构体变量赋值)</span><br>p1 = p2;  <span class="hljs-comment">// 相当于p1.x = p2.x;p1.y = p2.y;</span><br></code></pre></td></tr></table></figure><p>结构指针<br>和数组不同，结构变量的名字并不是结构变量的地址，<strong>必须使用&amp;运算符</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> *<span class="hljs-title">pDate</span> =</span> &amp;today;<br></code></pre></td></tr></table></figure><p>结构作为函数参数（<strong>与数组完全不一样！</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numberOfDays</span><span class="hljs-params">(struct date d)</span></span><br></code></pre></td></tr></table></figure><p>整个结构可以作为参数的值传入函数<br>这时候是在函数内新建一个结构变量，并复制调用者的结构的值<br>也可以返回一个结构</p><p>输入结构<br>没有直接的方式可以一次scanf一个结构<br>可以写一个函数来读入结构（<strong>函数调用时，传入函数的只是值！</strong>）<br>解决方案：在这个输入函数中，可以<strong>创建一个临时的结构变量</strong>，然后把这个结构返回给调用者</p><p><strong>结构指针作为参数</strong>（重中之重！）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> month;<br>    <span class="hljs-keyword">int</span> day;<br>    <span class="hljs-keyword">int</span> year;<br>&#125;myday;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> *<span class="hljs-title">p</span> =</span> &amp;myday;<br>(*p).month = <span class="hljs-number">12</span>;<br>p-&gt;month = <span class="hljs-number">12</span>;<span class="hljs-comment">//用-&gt;表示指针所指的结构变量中的成员</span><br></code></pre></td></tr></table></figure><p>结构数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">dates</span>[100];</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">dates</span>[]=</span><br>&#123;<br>    &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2005</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2005</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>结构中的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dateAndTime</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">sdate</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">time</span> <span class="hljs-title">stime</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>嵌套的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rectangle</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">pt1</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">pt2</span>;</span><br>&#125;;<br>如果有变量<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rectangle</span> <span class="hljs-title">r</span>;</span><br>就可以有：<br>    r.pt1.x<br>    r.pt1.y<br>    r.pt2.x<br>    r.pt2.y<br>如果有变量定义：<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rectangle</span> <span class="hljs-title">r</span>,*<span class="hljs-title">rp</span>;</span><br>    rp = &amp;r;<br>那么下面的四种形式是等价的：<br>    r.pt1.x<br>    rp-&gt;pt1.x<br>    (r.pt1).x<br>    (rp-&gt;pt1).x<br>但是没有rp-&gt;pt1-&gt;x<span class="hljs-comment">//此处的pt1不是指针</span><br></code></pre></td></tr></table></figure><h1 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h1><hr><p>自定义数据类型（typedef）<br>C语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Length;<br><span class="hljs-comment">//使得Lengrh成为int类型的别名</span><br><span class="hljs-comment">//Length这个名字就可以代替int出现在变量定义和参数声明的地方了</span><br>Length a,b,len;<br>Length numbers[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>typedef<br>声明新的类型的名字<br><strong>新的名字是某种类型的别名</strong><br><strong>改善了程序的可读性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int64_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ADate</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> month;<br>    <span class="hljs-keyword">int</span> day;<br>    <span class="hljs-keyword">int</span> year;<br>&#125;Date;<span class="hljs-comment">//简化了的名字</span><br><span class="hljs-keyword">int64_t</span> i = <span class="hljs-number">100000000000000</span>;<br>Date d = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2005</span>&#125;;<br></code></pre></td></tr></table></figure><hr><p><strong>联合</strong>（虽然有两个数据成员，但是这两个成员的存储空间是一样的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">AnElt4</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">char</span> c;<br>&#125;elt1,elt2;<br></code></pre></td></tr></table></figure><p>union的用处<br>读出寄存器数据（这个不在这篇文章的讨论范围内）<br>将读出的数据转换成可计算的数据类型（两个char类型转换成一个short或int或float类型）<br>根据公式计算</p><hr><p><strong>全局变量</strong><br>定义在函数外面的变量是全局变量<br>全局变量具有全局的生存期和作用域<br>它们与任何函数都无关<br>在任何函数内部都可以使用它们</p><p>全局变量初始化<br><strong>没有做初始化的全局变量会得到0值</strong>（本地变量则是得到一堆奇奇怪怪的值）<br><strong>指针会得到NULL值</strong><br>只能用编译时刻已知的值来初始化全局变量<br>它们的初始化发生在main函数之前</p><p>被隐藏的全局变量<br>如果函数内部存在与全局变量同名的变量，则<strong>全局变量被隐藏</strong></p><p>静态本地变量<br>在本地变量定义时加上<strong>static</strong>修饰符就成为静态本地变量<br>当函数离开的时候，静态本地变量会继续存在并保持其值<br>静态本地变量的初始化只会在第一次进入这个函数时做，<strong>以后进去函数时会保持上次离开时的值</strong></p><p>静态本地变量<strong>实际上是特殊的全局变量</strong><br>它们位于相同内存区域<br><strong>静态本地变量具有全局的生存期，函数内的局部作用域</strong><br>static在这里的意思是局部作用域（本地可访问）</p><p><strong>*返回指针的函数</strong><br>返回本地变量的地址是危险的<br>返回全局变量或静态本地变量的地址是安全的<br>返回在函数内malloc的内存是安全的，但是容易造成问题<br><strong>最好的做法是返回传入的指针！</strong></p><p>全局变量使用小tips<br><strong>不要使用全局变量来在函数间传递参数和结果</strong><br>尽量避免使用全局变量<br>*使用全局变量和静态本地变量的函数是线程不安全的</p><hr><p>编译预处理指令<br>开头的是编译预处理指令<br>它们不是C语言的成分，但是C语言程序离不开它们</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>用来定义一个宏</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> <span class="hljs-meta-string">&lt;名字&gt;</span> <span class="hljs-meta-string">&lt;值&gt;</span></span><br><span class="hljs-comment">//注意没有结尾的分号，因为不是C的语句</span><br><span class="hljs-comment">//名字必须是一个单词，值可以是各种东西</span><br></code></pre></td></tr></table></figure><p>在C语言的编译器开始编译之前，编译预处理程序（cpp）会把程序中的名字换成值<br><strong>完全的文本替换</strong></p><p><strong>宏（同样不是C语言的部分，不能带分号！）</strong><br>如果一个宏的值中有其他的宏的名字，也是会被替换的<br>如果一个宏的值超过一行，<strong>最后一行之前的行末需要加\</strong><br>宏的值后面出现的注释不会被当作宏的值的一部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRT printf(<span class="hljs-meta-string">&quot;%df&quot;</span>,PI);\</span><br><span class="hljs-meta">            printf(<span class="hljs-meta-string">&quot;%f\n&quot;</span>,PI2);</span><br></code></pre></td></tr></table></figure><p><strong>没有值的宏</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _DEBUG</span><br></code></pre></td></tr></table></figure><p>这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否被定义过了</p><p><strong>预定义的宏</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">_LINE_;_FILE_;_DATE_;_TIME_;_STDC_<br></code></pre></td></tr></table></figure><p><strong>像函数的宏</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cube(x) ((x)*(x)*(x))</span><br></code></pre></td></tr></table></figure><p><strong>错误定义的宏</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RADTODEG(x) (x*57.29578)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RADTODEG(x) (x)*57.29578<span class="hljs-comment">//错误的运算！</span></span><br></code></pre></td></tr></table></figure><p>一切都要带括号<br>整个值要括号<br>参数出现的每个地方都要括号</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">RADTODEG</span>(x) ((x)*<span class="hljs-number">57.29578</span>)<br></code></pre></td></tr></table></figure><p><strong>带参数的宏</strong><br>可以带多个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN(a,b) ((a)&gt;(b)?(b):(a))</span><br></code></pre></td></tr></table></figure><p>也可以组合（嵌套）使用替他宏</p><p><em>在大型程序的代码中使用非常普遍<br>可以非常复杂，如“产生”函数<br>在#和##这两个运算符的帮助下<br><em>*部分宏会被inline函数替代</em></em></p><p>其他编译预处理指令：条件编译，error。。。</p><hr><p>多个.c文件<br>main（）里的代码太长了，适合分成几个函数<br>一个源代码文件太长了，适合分成几个文件<br><strong>两个独立的源代码文件不能编译形成可执行的程序</strong></p><p><strong>头文件</strong><br>把函数原型放到一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中#include这个头文件，就能让编译器在编译的时候知道函数的原型</p><p><strong>#include</strong><br>编译预处理指令，和宏一样，在编译之前就处理了<br>它把那个文件的全部文本内容原封不动地插入到它所在的地方<br><strong>所以也不是一定要在.c文件的最前面#include</strong></p><p><strong>“”还是&lt;&gt;?</strong><br>include有两种形式来指出要插入的文件<br><strong>“”要求编译器首先在当前目录（.c文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找</strong><br>&lt;&gt;让编译器只在指定的目录去找<br>编译器自己知道自己的标准库的头文件在哪里<br>环境变量和编译器命令行参数也可以指定寻找头文件的目录</p><p><strong>include的误区</strong><br>include不是用来引入库的<br>stdio.h里只有printf的原型，printf的代码在另外的地方，某个.lib(Windows)或a(Unix)中<br>现在的C语言编译器默认会有引入所有的标准库<br>include<stdio.h>只是为了让编译器知道printf函数的原型，保证调用时给出的参数值是正确的类型</stdio.h></p><p><strong>不对外公开的函数</strong><br>在函数前面加上static就使得它成为只能在所在的编译单元中被使用的函数<br>在全局变量前面加上static就使得它成为只能在所在的编译单元中被使用的全局变量</p><hr><p><strong>声明</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> i;<span class="hljs-comment">//是变量的定义</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i;<span class="hljs-comment">//是变量的声明</span><br></code></pre></td></tr></table></figure><p>声明和定义<br><strong>声明是不产生代码的东西</strong><br><strong>定义是产生代码的东西</strong></p><p><strong>标志头文件结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __LIST_HEAD__</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __LIST_HEAF__</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;node.h&quot;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">list</span></span><br><span class="hljs-class">&#123;</span><br>    Node* head;<br>    Node* tail;<br>&#125;List;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>运用条件编译和宏，保证这个头文件在一个编译单元中只会被#include一次<br>$pragma once也能起到相同的作用，但是不是所有的编译器都支持</p><hr><p>格式化的输入输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span><br>%[flags][width][.prec][hlL]type<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Flag</th><th>含义</th></tr></thead><tbody><tr><td>-</td><td>左对齐</td></tr><tr><td>+</td><td>在前面放+或-</td></tr><tr><td>(space)</td><td>正数留空</td></tr><tr><td>0</td><td>0填充</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>width或prec</th><th>含义</th></tr></thead><tbody><tr><td>number</td><td>最小字符数</td></tr><tr><td>*</td><td>下一个参数是字符数</td></tr><tr><td>.number</td><td>小数点后的位数</td></tr><tr><td>.*</td><td>下一个参数是小数点后的位数</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%*d\n&quot;</span>,<span class="hljs-number">6</span>,<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>hlL(类型修饰)</th><th>含义</th></tr></thead><tbody><tr><td>hh</td><td>单个字节</td></tr><tr><td>h</td><td>short</td></tr><tr><td>l</td><td>long</td></tr><tr><td>ll</td><td>long long</td></tr><tr><td>L</td><td>long double</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>type</th><th>用于</th><th>typr</th><th>用于</th></tr></thead><tbody><tr><td>i或d</td><td>int</td><td>g</td><td>float</td></tr><tr><td>u</td><td>unsigned int</td><td>G</td><td>float</td></tr><tr><td>o</td><td>八进制</td><td>a或A</td><td>十六进制浮点</td></tr><tr><td>x</td><td>十六进制</td><td>c</td><td>char</td></tr><tr><td>X</td><td>字母大写的十六进制</td><td>s</td><td>字符串</td></tr><tr><td>f或F</td><td>float,6</td><td>p</td><td>指针</td></tr><tr><td>e或E</td><td>指数</td><td>n</td><td>读入/写出的个数</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span><br>%[flag]type<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>flag</th><th>含义</th><th>flag</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>跳过</td><td>l</td><td>long,double</td></tr><tr><td>数字</td><td>最大字符数</td><td>ll</td><td>long long</td></tr><tr><td>hh</td><td>char</td><td>L</td><td>long double</td></tr><tr><td>h</td><td>short</td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>type</th><th>用于</th><th>type</th><th>用于</th></tr></thead><tbody><tr><td>d</td><td>int</td><td>s</td><td>字符串（单词）</td></tr><tr><td>i</td><td>整数，可能为十六进制或八进制</td><td>[…]</td><td>所允许的字符</td></tr><tr><td>u</td><td>unsigned int</td><td>p</td><td>指针</td></tr><tr><td>o</td><td>八进制</td><td></td><td></td></tr><tr><td>x</td><td>十六进制</td><td></td><td></td></tr><tr><td>a,e,f,g</td><td>float</td><td></td><td></td></tr><tr><td>c</td><td>char</td><td></td></tr></tbody></table></div><p><strong>printf和scanf的返回值</strong><br>读入的项目数<br>输出的字符数<br>在要求严格的程序中，应该<strong>判断每次调用scanf或printf的返回值</strong>，从而了解程序运行中是否存在问题</p><hr><p>二进制文件<br>其实所有的文件最终都是二进制的<br>文本文件无非就是最简单的方式可以读写的文件<br>而<strong>二进制文件是需要专门的程序来读写的文件</strong><br>文本文件的输入输出是格式化，可能经过转码<br>（这一节听不懂可以不听。。。）</p><hr><p>按位运算<br>C有这些按位运算的运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">&amp; <span class="hljs-comment">//按位的与</span><br>| <span class="hljs-comment">//按位的或</span><br>~ <span class="hljs-comment">//按位取反</span><br>^ <span class="hljs-comment">//按位的异或 </span><br>&lt;&lt;//左移<br>&gt;&gt;<span class="hljs-comment">//右移</span><br></code></pre></td></tr></table></figure><p>（未完待续。。。）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：花了大概一周多的时间把C语言最基本的东西干完了，但这些东西大抵只是些皮毛。学习一个新东西，可以先观看视频了解大概轮廓，然后接下来啃书。&lt;/p&gt;
&lt;h1 id=&quot;Day1&quot;&gt;&lt;a href=&quot;#Day1&quot; class=&quot;headerlink&quot; title=&quot;Day1&quot;&gt;</summary>
      
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-《经济学原理》</title>
    <link href="http://example.com/2021/10/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E3%80%8B/"/>
    <id>http://example.com/2021/10/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E3%80%8B/</id>
    <published>2021-10-16T08:50:01.000Z</published>
    <updated>2021-11-16T08:54:36.589Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《经济学原理》-曼昆</strong></p><p>DAY1：2021年10月8日</p><h1 id="本书的总览"><a href="#本书的总览" class="headerlink" title="本书的总览"></a>本书的总览</h1><p><strong>导言部分（最基础的知识）</strong></p><p>第一章：“经济学十大原理”（经济学家的世界观，整个经济学的基础）主要介绍整本书中将出现的重要思想。</p><p>第二章：主要介绍经济学家如何研究他们的研究领域。1，假设在形成理论中的作用2，经济模型的概念3，经济学家在制定政策中的作用4，如何使用图形（包括被误用）</p><p>第三章：1，主要介绍比较优势理论（解释了为什么个人要与其邻居贸易，为什么一个国家要与其他国家贸易）2，市场力量如何协调许多个别的生产和消费决策3，为什么专业化，相互依赖和贸易会有利于每一个人。</p><p><strong>研究供求的工具</strong></p><p>第四章：主要介绍了供给曲线，需求曲线和市场均衡的概念。（供给与需求的市场力量）</p><p>第五章：弹性的概念（分析了三个事件）（弹性及其应用）</p><p>第六章：考察租金控制和最低工资法一类的价格控制，以及税收归宿（供给，需求与政府政策）</p><p>第七章：（消费者，生产者与市场效率）1，用消费者剩余和生产者剩余的概念扩大了供求分析2，消费者支付意愿和需求曲线之间的联系3，生产者生产成本和供给曲线之间的联系4，市场均衡使生产者和消费者剩余之和最大化5，了解市场配置的效率</p><p>第八，九章：实际应用“赋税的价值”（为什么税收引起无谓损失，什么决定了这种损失的大小），“国际贸易”（国际贸易的受益方和受损方，有关保护主义贸易政策的争论）</p><p><strong>微观经济学（较高深）</strong></p><p>为什么市场配置通常是合意的，政府如何改善市场配置。</p><p>第十章：“污染”这一类的外部效应如何会使市场结果无效率（外部性解释），无效率的解决方法（公开或私人）。</p><p>第十一章：“国防“这一类物品没有市场价值时产生的问题（公共物品和公共资源）。</p><p>第十二章：政府如何筹集支付公共物品所必需的收入。1，美国税制的制度背景2，效率和平等目标如何在设计税制时起作用</p><p>第十三章：介绍成本曲线，讨论了包括在企业成本中的内容——生产成本。</p><p>第十四章：介绍市场供给曲线，分析了价格接受企业的行为。</p><p>第十五章：1，讨论了作为市场上唯一卖者的企业的行为。2，讨论垄断定价的无效率，可能的政策反应和垄断者实行价格歧视的努力。（垄断）</p><p>第十六章：介绍只有几家卖家的市场，用囚徒模型解释战略相互作用。（寡头）</p><p>第十七章：1，考察有许多提供相似而不相同产品的卖者的市场行为。2，讨论了广告效果的争论。（垄断竞争）</p><p>第十八章：介绍要素价格与边际生产率之间的联系（生产要素市场）</p><p>第十九章：讨论了均衡工资的决定因素（补偿工资差别，人力资本和歧视）。</p><p>第二十章：1，考察了美国社会的不平等程度2，政府在改变收入分配中作用的不同观点3，帮助社会最贫困成员的各种政策。</p><p>第二十一章：用预算约束线和无差异曲线分析个人决策。</p><p>第二十二章：（微观经济学前言）介绍不对称信息，政治经济学和行为经济学。</p><p><strong>宏观经济学</strong></p><p>第二十三章：讨论国内生产总值和国名收入账户相关的统计数字的含义。</p><p>第二十四章：讨论消费物价指数的衡量与运用。</p><p>第二十五章：考察不同时期与不同国家生活水平差别巨大的决定因素。</p><p>第二十六章：讨论金融机构，考察这些机构在配置资源中的作用。</p><p>第二十七章：介绍现值，风险管理与资产评估。（基本金融工具）</p><p>第二十八章：考察失业率的长期决定因素。（寻找工作，最低工资法，工会的市场势力及效率工资）</p><p>第二十九章：介绍货币概念（经济学家角度），中央银行在控制货币量中的作用。</p><p>第三十章：介绍古典通货膨胀理论，讨论通货膨胀给社会带来的成本。</p><p>第三十一章：1，介绍储蓄，投资与贸易余额之间的关系2，名义和实际汇率之间的区别3，介绍购买力平价理论。</p><p>第三十二章：介绍古典国际物品与资本流动模型。（预算赤字与贸易赤字之间的联系，贸易政策的宏观经济影响）</p><p>第三十三章：介绍总需求与总供给模型。（根据有关经济周期的一些事实）</p><p>第三十四章：解释决策者如何可以移动总需求曲线（利用掌握的工具）。</p><p>第三十五章：1，解释为什么控制总需求的决策者面临通货膨胀与失业的权衡取舍关系2，为什么这种权衡取舍关系存在于短期中3，为什么它会最终消失。</p><p>第三十六章：宏观经济政策的五个争论问题1，政策积极主义的适当程度（对经济周期作出反应）2，规则与相机抉择之间的选择（运用货币政策）3，实现零通货膨胀的合意性4，政府预算平衡的重要性5，为鼓励储蓄进行税收改革的需要</p><p>我们为什么要学习经济学？</p><p>经济学有助于了解自己生活的世界，使个人更加精明的参与经济，还可以更好的理解经济政策的潜力与局限性。</p><p>DAY2：2021年10月9日</p><h1 id="第一章：经济学原理"><a href="#第一章：经济学原理" class="headerlink" title="第一章：经济学原理"></a>第一章：经济学原理</h1><p><strong>稀缺性</strong>：社会拥有的资源是有限的，因此不能生产人们希望拥有的所有物品与劳务。</p><p>经济学研究社会如何管理自己的稀缺资源。</p><p>原理一到四研究的是个人如何做出决策。</p><h2 id="原理一：人们面临权衡取舍"><a href="#原理一：人们面临权衡取舍" class="headerlink" title="原理一：人们面临权衡取舍"></a><strong>原理一：人们面临权衡取舍</strong></h2><p>做出决策要求我们在一个目标与另一个目标之间权衡取舍。</p><p>社会面临的权衡取舍是在效率与平等之间的。</p><p>效率是指社会能从其稀缺资源中得到的更多的东西（经济蛋糕的大小）。</p><p>平等是指将这些资源的成果公平地分配给社会成员（如何分割这块蛋糕）。</p><p>（政府想要把经济蛋糕切为更均等的小块时，这块蛋糕本身也就变小了。）</p><h2 id="原理二：某种东西的成本是为了得到它所放弃的东西"><a href="#原理二：某种东西的成本是为了得到它所放弃的东西" class="headerlink" title="原理二：某种东西的成本是为了得到它所放弃的东西"></a><strong>原理二：某种东西的成本是为了得到它所放弃的东西</strong></h2><p>做出决策就要比较可供选择的行动方案的成本与收益。（但某种行动的成本并不像乍看时那么明显）</p><p>一种东西的机会成本是为了得到这种东西所放弃的东西。</p><h2 id="原理三：理性人考虑边际量"><a href="#原理三：理性人考虑边际量" class="headerlink" title="原理三：理性人考虑边际量"></a><strong>原理三：理性人考虑边际量</strong></h2><p>边际变动：描述对现有行动的微小增量调整。（当考试临近时，我的决策不是在放弃考试或一天学习24个小时之间的选择，而是是否多花一小时复习功课而不是看电视）</p><p>人们通过考虑边际量（边际利益与边际成本）来做出最优决策</p><h2 id="原理四：人们会对激励做出反应"><a href="#原理四：人们会对激励做出反应" class="headerlink" title="原理四：人们会对激励做出反应"></a><strong>原理四：人们会对激励做出反应</strong></h2><p>许多政策改变了人们面临的成本或利益，从而改变了行为。</p><p>不仅应该考虑直接影响，而且还应该考虑通过激励发生的间接影响。</p><p>原理五到七研究的是人们如何相互交易</p><h2 id="原理五：贸易能使每个人状况更好"><a href="#原理五：贸易能使每个人状况更好" class="headerlink" title="原理五：贸易能使每个人状况更好"></a><strong>原理五：贸易能使每个人状况更好</strong></h2><p>贸易使每个人可以专门从事自己最擅长的活动。</p><p>通过与其他人交易，人们可以按较低的成本活获得各种各样的物品与劳务。</p><h2 id="原理六：市场通常是组织经济活动的一种好方法"><a href="#原理六：市场通常是组织经济活动的一种好方法" class="headerlink" title="原理六：市场通常是组织经济活动的一种好方法"></a><strong>原理六：市场通常是组织经济活动的一种好方法</strong></h2><p>市场经济：当许多企业和家庭在物品与劳务市场上相互交易时，通过他们的分散决策配置资源的经济。</p><p>价格就是看不见的手用来指引经济活动的工具。</p><p>价格既反映了一种物品的社会价值，也反映了生产该物品的社会成本。</p><p>重要推论：当政府阻止价格根据供求自发地调整时，它就限制了看不叫的手协调组成经济的千百万家庭和企业的能力。（中央计划经济）</p><p>DAY3：2021年10月10日</p><h2 id="原理七：政府有时可以改善市场效果"><a href="#原理七：政府有时可以改善市场效果" class="headerlink" title="原理七：政府有时可以改善市场效果"></a><strong>原理七：政府有时可以改善市场效果</strong></h2><p>看不见的手需要政府来保护它（只有产权得到保护，市场才能运行）</p><p>“经济参与者受利己所驱动，而市场中‘看不见的手’指引这种利己去促进一般社会福利“——斯密</p><p>政府干预经济的原因有两类：促进效率和促进平等。（大多数政策不是把经济蛋糕做大，而是改变蛋糕的分割）</p><p>市场失灵：市场本身不能有效配置资源的情况。市场失灵的可能原因是外部性和市场势力。</p><p>外部性：一个人的行为对旁观者福利的影响。</p><p>市场势力：一个经济活动者（或经济活动者的一个小集团）对市场价格有显著影响的能力。</p><p>看不见的手不能确保公平地分配经济成果。</p><p>市场经济根据人们生产其他人愿意买的东西的能力来给报酬。</p><p>政府有时可以改善市场结果并不意味着它总能这样。</p><p>原理八到十研究的是整体经济如何运行</p><h2 id="原理八：一国的生活水平取决于它生产物品与劳务的能力"><a href="#原理八：一国的生活水平取决于它生产物品与劳务的能力" class="headerlink" title="原理八：一国的生活水平取决于它生产物品与劳务的能力"></a><strong>原理八：一国的生活水平取决于它生产物品与劳务的能力</strong></h2><p>用生产率的差别解释各国和不同时期中生活水平的巨大差别。</p><p>一国的生产率增长率决定了平均收入增长率。</p><p>在考虑任何一项政策如何影响生活水平时，关键问题是这项政策如何影响我们生产物品与劳务的能力。</p><h2 id="原理九：当政府发行了过多货币时，物价上升"><a href="#原理九：当政府发行了过多货币时，物价上升" class="headerlink" title="原理九：当政府发行了过多货币时，物价上升"></a><strong>原理九：当政府发行了过多货币时，物价上升</strong></h2><p>通货膨胀：经济中物价总水平的上升</p><p>货币量的增加引起通货膨胀。</p><h2 id="原理十：社会面临通货膨胀与失业之间的短期权衡取舍"><a href="#原理十：社会面临通货膨胀与失业之间的短期权衡取舍" class="headerlink" title="原理十：社会面临通货膨胀与失业之间的短期权衡取舍"></a><strong>原理十：社会面临通货膨胀与失业之间的短期权衡取舍</strong></h2><p>增加经济中的货币量→通货膨胀和至少短期内降低失业水平。</p><p>菲利普斯曲线：通货膨胀与失业之间的短期权衡取舍</p><p>菲利普斯曲线有利于理解经济周期</p><p>决策者可以通过改变政府支出量，税收量和发行的货币量来影响经济所经历的通货膨胀与失业的组合。</p><p>DAY4：2021年10月16日</p><p>2021/11/16<br>一个月过去了，计划中道崩殂，因为数学课程的压力太大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;《经济学原理》-曼昆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DAY1：2021年10月8日&lt;/p&gt;
&lt;h1 id=&quot;本书的总览&quot;&gt;&lt;a href=&quot;#本书的总览&quot; class=&quot;headerlink&quot; title=&quot;本书的总览&quot;&gt;&lt;/a&gt;本书的总览&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    
    <category term="经济学" scheme="http://example.com/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>typora基础用法笔记</title>
    <link href="http://example.com/2021/10/16/typora%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/10/16/typora%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2021-10-16T08:32:27.000Z</published>
    <updated>2021-10-17T03:15:30.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础的使用语法"><a href="#基础的使用语法" class="headerlink" title="基础的使用语法"></a><strong>基础的使用语法</strong></h1><h2 id="段落与分割线"><a href="#段落与分割线" class="headerlink" title="段落与分割线"></a><strong>段落与分割线</strong></h2><p>使用enter直接切换到下一个段落，而使用shift+enter则切换到下一行(段与段的长度比行与行的长度长)<br>想要在段与段之间添加分割线可以使用<em>*</em></p><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a><strong>字体</strong></h2><p>加粗:文字前后分别添加”<em>*”<br>斜体:文字前后分别添加” </em> “<br>删除线:文字前后添加”~~”</p><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a><strong>标题</strong></h2><p>Markdown语法中的标题都是在文字面前使用”#”，前面有几个”#”就是几级标题(文字与#之间需保留空格)</p><hr><h2 id="块"><a href="#块" class="headerlink" title="块"></a><strong>块</strong></h2><p>代码块:将输入法切换至英文，输入”```”即可输入代码<br>公式块:使用快捷键ctrl+shift+M即可出现书写公式界面<br>引用块:将输入法切换为英文，输入符号&gt;再按下空格即可进入引用格式</p><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h2><p>使用typora工具栏中的段落-表格可以自动生成一个表格，左上角的栏目可以用于表格的调试</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>这是一个表格</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>这是表格内容</strong></td></tr></tbody></table></div><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a><strong>图片</strong></h2><p>直接使用 右键 - 复制 将网络图片、剪贴板图片复制到文档中<br>拖动本地图片到文档中<br>Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题<br>在 文件 - 偏好设置 - 编辑器 - 图像中可以设置图片保存的位置</p><hr><h2 id="打字机模式与专注模式"><a href="#打字机模式与专注模式" class="headerlink" title="打字机模式与专注模式"></a><strong>打字机模式与专注模式</strong></h2><p>打字机模式:使得你所编辑的那一行永远处于屏幕正中<br>专注模式:使你正在编辑的那一行保留颜色，而其他行的字体呈灰色</p><hr><h2 id="大纲-amp-文字侧边栏"><a href="#大纲-amp-文字侧边栏" class="headerlink" title="大纲&amp;文字侧边栏"></a><strong>大纲&amp;文字侧边栏</strong></h2><p>Typora 会根据你 Markdown 标记的 H1、H2、H3…… 各级标题为你呈现一个大纲。</p><hr><h1 id="进阶的使用方法—添加插件"><a href="#进阶的使用方法—添加插件" class="headerlink" title="进阶的使用方法—添加插件"></a>进阶的使用方法—添加插件</h1><p>—随缘更新……</p><hr><blockquote><p><a href="https://www.typora.net/support/">支持 | typora中文网</a><br><a href="https://www.typora.net/1736.html">Typora使用方法教程 | typora中文网</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础的使用语法&quot;&gt;&lt;a href=&quot;#基础的使用语法&quot; class=&quot;headerlink&quot; title=&quot;基础的使用语法&quot;&gt;&lt;/a&gt;&lt;strong&gt;基础的使用语法&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;段落与分割线&quot;&gt;&lt;a href=&quot;#段落与分割线&quot; cl</summary>
      
    
    
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>网站更新日志2021/10/16</title>
    <link href="http://example.com/2021/10/16/%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%972021-10-16/"/>
    <id>http://example.com/2021/10/16/%E7%BD%91%E7%AB%99%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%972021-10-16/</id>
    <published>2021-10-16T06:04:13.000Z</published>
    <updated>2021-10-16T06:08:50.933Z</updated>
    
    <content type="html"><![CDATA[<p>/将网站的主题从next更换为了fluid<br>/添加了页面图片<br>/添加了”about”页面更多的信息<br>/持续学习markdown文件编译技术，选择使用typora编译器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;/将网站的主题从next更换为了fluid&lt;br&gt;/添加了页面图片&lt;br&gt;/添加了”about”页面更多的信息&lt;br&gt;/持续学习markdown文件编译技术，选择使用typora编译器&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="更新" scheme="http://example.com/tags/%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://example.com/2021/10/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2021/10/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-10-15T13:10:50.000Z</published>
    <updated>2021-10-16T06:05:16.412Z</updated>
    
    <content type="html"><![CDATA[<p>这是我创建的第一个个人博客，内容应该不会太多。<br>在这里简要的说明一下，我目前还在学习大一基础课程中的程序设计，使用的是C语言编程工具。（菜鸟实锤）<br>建立个人博客主要是兴趣爱好使然，也是想记录分享下自己的学习，生活。（学Web前端技术也是为了能找口饭吃，，，）<br>下面简要的谈谈未来的工作：(学习进度会进行归纳整理并发布）<br>1，熟练应用MarkDown编译器（最基本的文章编写能力）<br>2，熟练规划设计hexo网站（页面美化，标签分类等）<br>3，不停的学习计算机技术！（在保障不挂科的情况下)<br>今天（15号）有幸得到某位大牛的指导：成为大佬很简单，不喊累，再加上强劲的执行力即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是我创建的第一个个人博客，内容应该不会太多。&lt;br&gt;在这里简要的说明一下，我目前还在学习大一基础课程中的程序设计，使用的是C语言编程工具。（菜鸟实锤）&lt;br&gt;建立个人博客主要是兴趣爱好使然，也是想记录分享下自己的学习，生活。（学Web前端技术也是为了能找口饭吃，，，）&lt;b</summary>
      
    
    
    
    
  </entry>
  
</feed>
